<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Interface Segregation Principle | Felpo Blog</title>
<meta name=keywords content><meta name=description content="O Princípio de Segregação de Interface, formulado por Robert C. Martin (também conhecido como Uncle Bob), estabelece uma regra simples: nenhum cliente deve ser forçado a depender de métodos que não utiliza.
Em termos práticos, isso significa que é melhor ter várias interfaces pequenas e específicas do que uma interface gigantesca que tenta resolver todos os problemas do universo. É como tentar usar um único aplicativo para programar, editar imagens, gerenciar finanças e tocar música — no fim, ele faz tudo de forma mediana ou mal feita. Já ferramentas especializadas, como um editor de código, um software de design e um app de contabilidade, cada uma focada em seu propósito, entregam muito mais valor."><meta name=author content><link rel=canonical href=https://blog.felpo.dev/posts/solid-interface-segregation-principle/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.felpo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.felpo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.felpo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.felpo.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.felpo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.felpo.dev/posts/solid-interface-segregation-principle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.felpo.dev/posts/solid-interface-segregation-principle/"><meta property="og:site_name" content="Felpo Blog"><meta property="og:title" content="SOLID Interface Segregation Principle"><meta property="og:description" content="O Princípio de Segregação de Interface, formulado por Robert C. Martin (também conhecido como Uncle Bob), estabelece uma regra simples: nenhum cliente deve ser forçado a depender de métodos que não utiliza.
Em termos práticos, isso significa que é melhor ter várias interfaces pequenas e específicas do que uma interface gigantesca que tenta resolver todos os problemas do universo. É como tentar usar um único aplicativo para programar, editar imagens, gerenciar finanças e tocar música — no fim, ele faz tudo de forma mediana ou mal feita. Já ferramentas especializadas, como um editor de código, um software de design e um app de contabilidade, cada uma focada em seu propósito, entregam muito mais valor."><meta property="og:locale" content="pt-br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Interface Segregation Principle"><meta name=twitter:description content="O Princípio de Segregação de Interface, formulado por Robert C. Martin (também conhecido como Uncle Bob), estabelece uma regra simples: nenhum cliente deve ser forçado a depender de métodos que não utiliza.
Em termos práticos, isso significa que é melhor ter várias interfaces pequenas e específicas do que uma interface gigantesca que tenta resolver todos os problemas do universo. É como tentar usar um único aplicativo para programar, editar imagens, gerenciar finanças e tocar música — no fim, ele faz tudo de forma mediana ou mal feita. Já ferramentas especializadas, como um editor de código, um software de design e um app de contabilidade, cada uma focada em seu propósito, entregam muito mais valor."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.felpo.dev/posts/"},{"@type":"ListItem","position":2,"name":"SOLID Interface Segregation Principle","item":"https://blog.felpo.dev/posts/solid-interface-segregation-principle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Interface Segregation Principle","name":"SOLID Interface Segregation Principle","description":"O Princípio de Segregação de Interface, formulado por Robert C. Martin (também conhecido como Uncle Bob), estabelece uma regra simples: nenhum cliente deve ser forçado a depender de métodos que não utiliza.\nEm termos práticos, isso significa que é melhor ter várias interfaces pequenas e específicas do que uma interface gigantesca que tenta resolver todos os problemas do universo. É como tentar usar um único aplicativo para programar, editar imagens, gerenciar finanças e tocar música — no fim, ele faz tudo de forma mediana ou mal feita. Já ferramentas especializadas, como um editor de código, um software de design e um app de contabilidade, cada uma focada em seu propósito, entregam muito mais valor.\n","keywords":[],"articleBody":"O Princípio de Segregação de Interface, formulado por Robert C. Martin (também conhecido como Uncle Bob), estabelece uma regra simples: nenhum cliente deve ser forçado a depender de métodos que não utiliza.\nEm termos práticos, isso significa que é melhor ter várias interfaces pequenas e específicas do que uma interface gigantesca que tenta resolver todos os problemas do universo. É como tentar usar um único aplicativo para programar, editar imagens, gerenciar finanças e tocar música — no fim, ele faz tudo de forma mediana ou mal feita. Já ferramentas especializadas, como um editor de código, um software de design e um app de contabilidade, cada uma focada em seu propósito, entregam muito mais valor.\nO Problema das Interfaces Gordas Imagine que você está desenvolvendo um sistema para uma biblioteca e cria uma interface chamada IFuncionario com os seguintes métodos:\n- catalogarLivros() - atenderClientes() - limparBanheiros() - fazerCafe() - programarSistema() - dirigirBibliotecaBus() - ensinarCriancas() À primeira vista, pode parecer eficiente ter uma interface que cubra todas as responsabilidades possíveis de um funcionário. Afinal, economiza tempo de design, não é mesmo? Errado. Isso é o equivalente programático de pedir para um bibliotecário também ser faxineiro, barista, desenvolvedor de software, motorista e professor — tudo ao mesmo tempo.\nO resultado é que qualquer classe que implemente IFuncionario será obrigada a implementar métodos que podem não fazer sentido para seu contexto específico. O bibliotecário responsável apenas pelo atendimento ao público terá que implementar programarSistema() retornando uma exceção ou, pior ainda, um método vazio que não faz absolutamente nada — o que é o equivalente digital de um suspiro resignado.\nA Solução Elegante O ISP sugere quebrar essa interface monolítica em várias interfaces menores e mais específicas:\n- IAtendente: atenderClientes() - ICatalogador: catalogarLivros() - ILimpeza: limparBanheiros() - IDesenvolvedor: programarSistema() - IMotorista: dirigirBibliotecaBus() Agora, cada classe pode implementar apenas as interfaces que fazem sentido para seu papel específico. O atendente implementa IAtendente, o programador implementa IDesenvolvedor, e o funcionário multitalentoso (que sempre existe em toda organização) pode implementar múltiplas interfaces conforme necessário.\nBenefícios Práticos A aplicação correta do ISP traz vantagens tangíveis que vão muito além da satisfação estética de ter código bem organizado:\nManutenibilidade: Quando você precisa modificar um método relacionado ao atendimento ao cliente, apenas as classes que implementam IAtendente são potencialmente afetadas. Não há risco de quebrar acidentalmente o sistema de catalogação porque alguém mudou uma assinatura de método.\nEficiência de Compilação: Em linguagens compiladas como C++, Java ou C#, este benefício é particularmente relevante. Quando você modifica apenas a interface IAtendente, o compilador precisa recompilar somente as classes que dependem dessa interface específica. Com uma interface monolítica como IFuncionario, uma mudança em qualquer método forçaria a recompilação de todas as classes que implementam a interface, mesmo aquelas que não utilizam o método modificado. Em projetos grandes, isso pode significar a diferença entre uma compilação de 30 segundos e uma de 20 minutos — tempo suficiente para fazer um café e questionar suas escolhas de carreira.\nTestabilidade: Testes unitários ficam mais simples e focados. Você pode testar especificamente as funcionalidades de atendimento sem se preocupar com a complexidade desnecessária de métodos não relacionados.\nFlexibilidade: Novas funcionalidades podem ser adicionadas através de novas interfaces específicas, sem impactar implementações existentes. É como adicionar novos cômodos a uma casa sem precisar reformar a estrutura inteira.\nClareza de Código: Cada interface comunica claramente sua intenção. Quando alguém vê uma classe implementando ICatalogador, imediatamente entende que essa classe tem responsabilidades relacionadas à catalogação de livros.\nQuando Segregar (E Quando Não Segregar) Como todo princípio de engenharia de software, o ISP deve ser aplicado com bom senso. Não faz sentido criar uma interface separada para cada método individual — isso seria como ter um funcionário específico para cada letra do alfabeto em uma biblioteca.\nA segregação deve ser baseada em responsabilidades coesas e comportamentos relacionados. Se dois métodos frequentemente são utilizados juntos e raramente separados, provavelmente pertencem à mesma interface.\nConclusão O Princípio de Segregação de Interface é, essencialmente, uma aplicação do bom senso organizacional ao mundo da programação. Assim como não esperaríamos que um único funcionário dominasse todas as habilidades possíveis de uma organização, não devemos esperar que uma única interface cubra todas as responsabilidades possíveis de um sistema.\nImplementar o ISP corretamente pode parecer mais trabalhoso inicialmente — afinal, é mais fácil jogar tudo em uma interface gigante do que pensar cuidadosamente sobre responsabilidades e segregações apropriadas. Porém, assim como investir tempo organizando sua casa evita horas procurando as chaves do carro, investir tempo em interfaces bem segregadas economiza dias de debugging e refatoração no futuro.\nNo final das contas, o ISP nos lembra de que, no desenvolvimento de software, como na vida, especialização e foco geralmente produzem melhores resultados do que tentar ser especialista em tudo ao mesmo tempo. E isso, felizmente, é uma lição que não requer uma interface para ser implementada.\n","wordCount":"807","inLanguage":"en","datePublished":"2025-06-08T00:00:00Z","dateModified":"2025-06-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.felpo.dev/posts/solid-interface-segregation-principle/"},"publisher":{"@type":"Organization","name":"Felpo Blog","logo":{"@type":"ImageObject","url":"https://blog.felpo.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.felpo.dev/ accesskey=h title="Felpo Blog (Alt + H)">Felpo Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SOLID Interface Segregation Principle</h1><div class=post-meta><span title='2025-06-08 00:00:00 +0000 UTC'>June 8, 2025</span></div></header><div class=post-content><p>O Princípio de Segregação de Interface, formulado por Robert C. Martin (também conhecido como Uncle Bob), estabelece uma regra simples: <em>nenhum cliente deve ser forçado a depender de métodos que não utiliza</em>.</p><p>Em termos práticos, isso significa que é melhor ter várias interfaces pequenas e específicas do que uma interface gigantesca que tenta resolver todos os problemas do universo. É como tentar usar um único aplicativo para programar, editar imagens, gerenciar finanças e tocar música — no fim, ele faz tudo de forma mediana ou mal feita. Já ferramentas especializadas, como um editor de código, um software de design e um app de contabilidade, cada uma focada em seu propósito, entregam muito mais valor.</p><h2 id=o-problema-das-interfaces-gordas>O Problema das Interfaces Gordas<a hidden class=anchor aria-hidden=true href=#o-problema-das-interfaces-gordas>#</a></h2><p>Imagine que você está desenvolvendo um sistema para uma biblioteca e cria uma interface chamada <code>IFuncionario</code> com os seguintes métodos:</p><pre tabindex=0><code>- catalogarLivros()
- atenderClientes()
- limparBanheiros()
- fazerCafe()
- programarSistema()
- dirigirBibliotecaBus()
- ensinarCriancas()
</code></pre><p>À primeira vista, pode parecer eficiente ter uma interface que cubra todas as responsabilidades possíveis de um funcionário. Afinal, economiza tempo de design, não é mesmo? Errado. Isso é o equivalente programático de pedir para um bibliotecário também ser faxineiro, barista, desenvolvedor de software, motorista e professor — tudo ao mesmo tempo.</p><p>O resultado é que qualquer classe que implemente <code>IFuncionario</code> será obrigada a implementar métodos que podem não fazer sentido para seu contexto específico. O bibliotecário responsável apenas pelo atendimento ao público terá que implementar <code>programarSistema()</code> retornando uma exceção ou, pior ainda, um método vazio que não faz absolutamente nada — o que é o equivalente digital de um suspiro resignado.</p><h2 id=a-solução-elegante>A Solução Elegante<a hidden class=anchor aria-hidden=true href=#a-solução-elegante>#</a></h2><p>O ISP sugere quebrar essa interface monolítica em várias interfaces menores e mais específicas:</p><pre tabindex=0><code>- IAtendente: atenderClientes()
- ICatalogador: catalogarLivros()
- ILimpeza: limparBanheiros()
- IDesenvolvedor: programarSistema()
- IMotorista: dirigirBibliotecaBus()
</code></pre><p>Agora, cada classe pode implementar apenas as interfaces que fazem sentido para seu papel específico. O atendente implementa <code>IAtendente</code>, o programador implementa <code>IDesenvolvedor</code>, e o funcionário multitalentoso (que sempre existe em toda organização) pode implementar múltiplas interfaces conforme necessário.</p><h2 id=benefícios-práticos>Benefícios Práticos<a hidden class=anchor aria-hidden=true href=#benefícios-práticos>#</a></h2><p>A aplicação correta do ISP traz vantagens tangíveis que vão muito além da satisfação estética de ter código bem organizado:</p><p><strong>Manutenibilidade</strong>: Quando você precisa modificar um método relacionado ao atendimento ao cliente, apenas as classes que implementam <code>IAtendente</code> são potencialmente afetadas. Não há risco de quebrar acidentalmente o sistema de catalogação porque alguém mudou uma assinatura de método.</p><p><strong>Eficiência de Compilação</strong>: Em linguagens compiladas como C++, Java ou C#, este benefício é particularmente relevante. Quando você modifica apenas a interface <code>IAtendente</code>, o compilador precisa recompilar somente as classes que dependem dessa interface específica. Com uma interface monolítica como <code>IFuncionario</code>, uma mudança em qualquer método forçaria a recompilação de <em>todas</em> as classes que implementam a interface, mesmo aquelas que não utilizam o método modificado. Em projetos grandes, isso pode significar a diferença entre uma compilação de 30 segundos e uma de 20 minutos — tempo suficiente para fazer um café e questionar suas escolhas de carreira.</p><p><strong>Testabilidade</strong>: Testes unitários ficam mais simples e focados. Você pode testar especificamente as funcionalidades de atendimento sem se preocupar com a complexidade desnecessária de métodos não relacionados.</p><p><strong>Flexibilidade</strong>: Novas funcionalidades podem ser adicionadas através de novas interfaces específicas, sem impactar implementações existentes. É como adicionar novos cômodos a uma casa sem precisar reformar a estrutura inteira.</p><p><strong>Clareza de Código</strong>: Cada interface comunica claramente sua intenção. Quando alguém vê uma classe implementando <code>ICatalogador</code>, imediatamente entende que essa classe tem responsabilidades relacionadas à catalogação de livros.</p><h2 id=quando-segregar-e-quando-não-segregar>Quando Segregar (E Quando Não Segregar)<a hidden class=anchor aria-hidden=true href=#quando-segregar-e-quando-não-segregar>#</a></h2><p>Como todo princípio de engenharia de software, o ISP deve ser aplicado com bom senso. Não faz sentido criar uma interface separada para cada método individual — isso seria como ter um funcionário específico para cada letra do alfabeto em uma biblioteca.</p><p>A segregação deve ser baseada em responsabilidades coesas e comportamentos relacionados. Se dois métodos frequentemente são utilizados juntos e raramente separados, provavelmente pertencem à mesma interface.</p><h2 id=conclusão>Conclusão<a hidden class=anchor aria-hidden=true href=#conclusão>#</a></h2><p>O Princípio de Segregação de Interface é, essencialmente, uma aplicação do bom senso organizacional ao mundo da programação. Assim como não esperaríamos que um único funcionário dominasse todas as habilidades possíveis de uma organização, não devemos esperar que uma única interface cubra todas as responsabilidades possíveis de um sistema.</p><p>Implementar o ISP corretamente pode parecer mais trabalhoso inicialmente — afinal, é mais fácil jogar tudo em uma interface gigante do que pensar cuidadosamente sobre responsabilidades e segregações apropriadas. Porém, assim como investir tempo organizando sua casa evita horas procurando as chaves do carro, investir tempo em interfaces bem segregadas economiza dias de debugging e refatoração no futuro.</p><p>No final das contas, o ISP nos lembra de que, no desenvolvimento de software, como na vida, especialização e foco geralmente produzem melhores resultados do que tentar ser especialista em tudo ao mesmo tempo. E isso, felizmente, é uma lição que não requer uma interface para ser implementada.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.felpo.dev/>Felpo Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>