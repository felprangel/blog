<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Guia básico de NGINX | Felpo Blog</title>
<meta name=keywords content><meta name=description content="Hoje vou fazer um dump de tudo que sei de NGINX, mostrando que não é difícil dar manutenção nos arquivos de configuração do seu servidor.
Depois de ler esse post você vai poder:

Entender os arquivos de configuração do NGINX
Configurar o NGINX como um servidor web
Configurar o NGINX como um proxy reverso
Configurar o NGINX como um load balancer

Índice

Introdução ao NGINX
Como instalar o NGINX
Introdução às configurações do NGINX
Como configurar um servidor web básico

Escrevendo seu primeiro arquivo de configuração
Como validar e recarregar os arquivos de configuração
Como entender as diretivas e contextos no NGINX
Como servir conteúdo estático usando NGINX
Lidando com tipos de arquivo estático no NGINX
Como incluir arquivos de configuração parciais


Roteamento dinâmico no NGINX

Correspondência de localização
Variáveis no NGINX
Redirecionamentos e reescritas
Como tentar múltiplos arquivos


Logs no NGINX
Como usar o NGINX como um proxy reverso

Node com NGINX


Como usar o NGINX como um load balancer
Como configurar processos worker e conexões worker

Introdução ao NGINX
Apesar de ser mais conhecido como um servidor web, o NGINX é basicamente um servidor de proxy reverso."><meta name=author content><link rel=canonical href=https://blog.felpo.dev/posts/guia-b%C3%A1sico-de-nginx/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.felpo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.felpo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.felpo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.felpo.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.felpo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.felpo.dev/posts/guia-b%C3%A1sico-de-nginx/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.felpo.dev/posts/guia-b%C3%A1sico-de-nginx/"><meta property="og:site_name" content="Felpo Blog"><meta property="og:title" content="Guia básico de NGINX"><meta property="og:description" content="Hoje vou fazer um dump de tudo que sei de NGINX, mostrando que não é difícil dar manutenção nos arquivos de configuração do seu servidor.
Depois de ler esse post você vai poder:
Entender os arquivos de configuração do NGINX Configurar o NGINX como um servidor web Configurar o NGINX como um proxy reverso Configurar o NGINX como um load balancer Índice Introdução ao NGINX Como instalar o NGINX Introdução às configurações do NGINX Como configurar um servidor web básico Escrevendo seu primeiro arquivo de configuração Como validar e recarregar os arquivos de configuração Como entender as diretivas e contextos no NGINX Como servir conteúdo estático usando NGINX Lidando com tipos de arquivo estático no NGINX Como incluir arquivos de configuração parciais Roteamento dinâmico no NGINX Correspondência de localização Variáveis no NGINX Redirecionamentos e reescritas Como tentar múltiplos arquivos Logs no NGINX Como usar o NGINX como um proxy reverso Node com NGINX Como usar o NGINX como um load balancer Como configurar processos worker e conexões worker Introdução ao NGINX Apesar de ser mais conhecido como um servidor web, o NGINX é basicamente um servidor de proxy reverso."><meta property="og:locale" content="pt-br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-31T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Guia básico de NGINX"><meta name=twitter:description content="Hoje vou fazer um dump de tudo que sei de NGINX, mostrando que não é difícil dar manutenção nos arquivos de configuração do seu servidor.
Depois de ler esse post você vai poder:

Entender os arquivos de configuração do NGINX
Configurar o NGINX como um servidor web
Configurar o NGINX como um proxy reverso
Configurar o NGINX como um load balancer

Índice

Introdução ao NGINX
Como instalar o NGINX
Introdução às configurações do NGINX
Como configurar um servidor web básico

Escrevendo seu primeiro arquivo de configuração
Como validar e recarregar os arquivos de configuração
Como entender as diretivas e contextos no NGINX
Como servir conteúdo estático usando NGINX
Lidando com tipos de arquivo estático no NGINX
Como incluir arquivos de configuração parciais


Roteamento dinâmico no NGINX

Correspondência de localização
Variáveis no NGINX
Redirecionamentos e reescritas
Como tentar múltiplos arquivos


Logs no NGINX
Como usar o NGINX como um proxy reverso

Node com NGINX


Como usar o NGINX como um load balancer
Como configurar processos worker e conexões worker

Introdução ao NGINX
Apesar de ser mais conhecido como um servidor web, o NGINX é basicamente um servidor de proxy reverso."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.felpo.dev/posts/"},{"@type":"ListItem","position":2,"name":"Guia básico de NGINX","item":"https://blog.felpo.dev/posts/guia-b%C3%A1sico-de-nginx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Guia básico de NGINX","name":"Guia básico de NGINX","description":"Hoje vou fazer um dump de tudo que sei de NGINX, mostrando que não é difícil dar manutenção nos arquivos de configuração do seu servidor.\nDepois de ler esse post você vai poder:\nEntender os arquivos de configuração do NGINX Configurar o NGINX como um servidor web Configurar o NGINX como um proxy reverso Configurar o NGINX como um load balancer Índice Introdução ao NGINX Como instalar o NGINX Introdução às configurações do NGINX Como configurar um servidor web básico Escrevendo seu primeiro arquivo de configuração Como validar e recarregar os arquivos de configuração Como entender as diretivas e contextos no NGINX Como servir conteúdo estático usando NGINX Lidando com tipos de arquivo estático no NGINX Como incluir arquivos de configuração parciais Roteamento dinâmico no NGINX Correspondência de localização Variáveis no NGINX Redirecionamentos e reescritas Como tentar múltiplos arquivos Logs no NGINX Como usar o NGINX como um proxy reverso Node com NGINX Como usar o NGINX como um load balancer Como configurar processos worker e conexões worker Introdução ao NGINX Apesar de ser mais conhecido como um servidor web, o NGINX é basicamente um servidor de proxy reverso.\n","keywords":[],"articleBody":"Hoje vou fazer um dump de tudo que sei de NGINX, mostrando que não é difícil dar manutenção nos arquivos de configuração do seu servidor.\nDepois de ler esse post você vai poder:\nEntender os arquivos de configuração do NGINX Configurar o NGINX como um servidor web Configurar o NGINX como um proxy reverso Configurar o NGINX como um load balancer Índice Introdução ao NGINX Como instalar o NGINX Introdução às configurações do NGINX Como configurar um servidor web básico Escrevendo seu primeiro arquivo de configuração Como validar e recarregar os arquivos de configuração Como entender as diretivas e contextos no NGINX Como servir conteúdo estático usando NGINX Lidando com tipos de arquivo estático no NGINX Como incluir arquivos de configuração parciais Roteamento dinâmico no NGINX Correspondência de localização Variáveis no NGINX Redirecionamentos e reescritas Como tentar múltiplos arquivos Logs no NGINX Como usar o NGINX como um proxy reverso Node com NGINX Como usar o NGINX como um load balancer Como configurar processos worker e conexões worker Introdução ao NGINX Apesar de ser mais conhecido como um servidor web, o NGINX é basicamente um servidor de proxy reverso.\nQuando uma request buscando conteúdo estático chega, o NGINX simplesmente responde com o arquivo, sem rodar nenhum processo adicional. Isso não significa que o NGINX não consegue lidar com requests que precisam de um processamento por uma linguagem de programação dinâmica. Nesses casos, o NGINX simplesmente delega a tarefa para processos separados como o PHP-FPM, Node.js ou Python. Então, quando o processo termina, o NGINX faz a proxy de resposta de volta pra o cliente.\nComo instalar o NGINX Em sistemas baseados em Debian/Ubuntu normalmente é apenas rodar:\nsudo apt install nginx Em caso de problemas você pode consultar a documentação oficial\nApós a instalação, o NGINX deve estar registrado como um serviço do systemd. Para checar, execute o seguinte comando:\nsudo systemctl status nginx Se o serviço estiver rodando, você está pronto para começar. Caso contrário você pode iniciar o serviço com o seguinte comando:\nsudo systemctl start nginx Por último, para um verificação visual de que tudo está rodando e funcionando como deveria, abra o localhost no seu navegador e você deve conseguir ver a tela inicial do NGINX\nNGINX normalmente é instalado no diretório /etc/nginx e a maioria do nosso trabalho nas seções que estão por vir vão ser feitas aqui.\nParabéns! Agora você tem um NGINX rodando na sua máquina. Agora é hora de pular de cabeça no NGINX.\nIntrodução as configurações do NGINX Como um servidor web, o trabalho do NGINX é servir conteúdo estático aos clientes. Mas como esse conteúdo vai ser servido é normalmente controlado por arquivos de configuração.\nOs arquivos de configuração do NGINX acabam com a extensão .conf e normalmente estão dentro da pasta /etc/nginx. Vamos começar entrando nesse diretório e listando todos os arquivos:\ncd /etc/nginx ls -lh # drwxr-xr-x 1 root root 4.0K Feb 24 23:48 conf.d # -rw-r--r-- 1 root root 1007 Feb 5 11:06 fastcgi_params # -rw-r--r-- 1 root root 5.3K Feb 5 11:06 mime.types # lrwxrwxrwx 1 root root 22 Feb 5 14:26 modules -\u003e /usr/lib/nginx/modules # -rw-r--r-- 1 root root 648 Feb 5 14:26 nginx.conf # -rw-r--r-- 1 root root 636 Feb 5 11:06 scgi_params # -rw-r--r-- 1 root root 664 Feb 5 11:06 uwsgi_params Entre esses arquivos, deve ter um chamado nginx.conf. Esse é o arquivo de configuração principal do NGINX. Você pode dar uma olhada no conteúdo do arquivo com o cat:\ncat nginx.conf # user nginx; # worker_processes auto; # error_log /var/log/nginx/error.log notice; # pid /var/run/nginx.pid; # events { # worker_connections 1024; # } # http { # include /etc/nginx/mime.types; # default_type application/octet-stream; # log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # access_log /var/log/nginx/access.log main; # sendfile on; # #tcp_nopush on; # keepalive_timeout 65; # #gzip on; # include /etc/nginx/conf.d/*.conf; # } Tentar entender esse arquivo nesse estado é um pesadelo. Vamos renomeá-lo e criar um novo arquivo vazio:\n# renomeia o arquivo sudo mv nginx.conf nginx.conf.backup # cria um novo arquivo sudo touch nginx.conf Não é recomendado editar o arquivo nginx.conf original a não ser que você saiba exatamente o que você está fazendo. Para fins educativos, estamos renomeando, mas depois, você vai ver como deveria configurar um servidor em um caso real.\nComo configurar um servidor web básico Nessa seção, vamos colocar a mão na masse e configurar um simples servidor web estático. O intuito dessa seção é introduzir você para a sintaxe fundamental dos conceitos dos arquivos de configuração do NGINX.\nEscrevendo seu primeiro arquivo de configuração Comece abrindo seu recém criado nginx.conf usando seu editor de texto favorito, pra esse exemplo, vou usar o nano:\nsudo nano /etc/nginx/nginx.conf Depois de abrir o arquivo, atualize seu conteúdo para que fique dessa forma:\nevents { } http { server { listen 80; server_name nginx.test; return 200 \"Hello World!\\n\"; } } Se você tem experiência na construção de API REST você deve ter deduzido da linha com return 200 \"\"Hello World!\\n\"; que o servidor foi configurado para responder com status code de 200 e a mensagem “Hello World!”\nNão se preocupe se você não entendeu nada além disso nesse momento. Eu vou explicar esse arquivo linha a linha, mas primeiro, vamos ver essa configuração em ação.\nComo validar e recarregar os arquivos de configuração Depois de escrever um novo arquivo de configuração ou atualizar um antigo, a primeira coisa a se fazer é checar se existe algum erro de sintaxe no arquivo. O binário do nginx inclui a opção -t que faz exatamente isso\nsudo nginx -t # nginx: the configuration file /etc/nginx/nginx.conf syntax is ok # nginx: configuration file /etc/nginx/nginx.conf test is successful Se exite algum erro de sintaxe, o comando vai te alertar sobre ele, incluindo o número da linha.\nApesar do arquivo de configuração estar certo, o NGINX não vai usá-lo. Do jeito que o NGINX funciona ele lê o arquivo de configuração uma vez e continua rodando baseado nessa primeira leitura.\nSe você atualizar o arquivo de configuração, então você precisa instruir o NGINX explicitamente para recarregar o arquivo de configuração. Existem duas formas de fazer isso:\nVocê pode reiniciar o serviço do NGINX executando o comando sudo systemctl restart nginx Você pode mandar um sinal de reload para o NGINX executando o comando sudo nginx -s reload O -s é usado para enviar vários sinais para o NGINX. O sinais disponíveis são stop, quit, reload, e reopen. Entre os dois jeitos de atualizar o arquivo, eu prefiro o segundo, simplesmente por que é menos coisas para digitar.\numa ver que você tenha recarregado o arquivo de configuração rodando o comando nginx -s reload, você pode ver isso em ação fazendo uma request get para o servidor:\ncurl -i http://nginx.test # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Mon, 24 Feb 2025 23:56:44 GMT # Content-Type: text/plain # Content-Length: 13 # Connection: keep-alive # Hello World! O servidor está respondendo com um status code de 200 e a mensagem esperada. Parabéns por chegar tão longe! Agora é hora de algumas explicações.\nComo entender as diretivas e contextos no NGINX As poucas linhas de código que você escreveu até agora, apesar de parecerem simples, introduzem duas das mais importantes terminologias dos arquivos de configuração do NGINX. Elas são diretivas e contextos.\nTecnicamente, tudo dentro de um arquivo de configuração do NGINX é uma diretiva. Diretivas são de dois tipos:\nDiretivas simples Diretivas de bloco Uma diretiva simples consiste do nome da diretiva e os parâmetros delimitados por espaços, como listen, return e outros. Diretivas simples são terminadas por ponto e vírgula.\nDiretivas de bloco são similares das diretivas simples, mas ao invés de terminar com ponto e vírgula, eles terminam com um par de chaves {} fechando instruções adicionais.\nUma diretiva de bloco capaz de conter outras diretivas dentro é chamada de contexto, que são os events, http e por aí vai. Existem quatro contextos principais no NGINX:\nevents {} - O contexto de events é usado para definir a configuração global de como o NGINX vai lidar com as requests de um modo geral. Só pode existir um contexto de events em um arquivo de configuração válido. http {} - Evidente pelo nome, o contexto de http é usado para definir a configuração de como o servidor vai lidar com requests HTTP e HTTPS, especificamente. Só pode existir um contexto http em um arquivo de configuração válido. server {} - O contexto de server é aninhado dentro do contexto de http e usado para configurar servidores virtuais específicos em apenas um host. Podem existir vários contexto de server dentro de um contexto de http. Cada contexto de server é considerado um host virtual. main - O contexto main é o próprio arquivo de configuração. Qualquer coisa escrita fora dos três contextos mencionados anteriormente está no contexto main. Você pode considerar contextos do NGINX como escopos em outras linguagens de programação. Existe também uma certa forma de herança entre eles. Você pode encontrar um índice de diretivas em ordem alfabética na documentação oficial.\nEu mencionei que podem existir múltiplos contextos de server no arquivo de configuração. Mas quando a request chega no servidor, como o NGINX sabe qual dos contextos deve lidar com a request?\nA diretiva de listen é um dos jeitos de identificar o contexto server correto na configuração. Considere o seguinte cenário:\nevents { } http { server { listen 80; server_name nginx.test; return 200 \"resposta da porta 80!\\n\"; } server { listen 8080; server_name nginx.test; return 200 \"resposta da porta 8080!\\n\"; } } Agora se você mandar uma request para http://nginx.test:80 você vai receber “resposta da porta 80!” como resposta. E se você mandar uma request para http://nginx.test:8080 você vai receber “resposta da porta 8080!” como uma resposta:\ncurl nginx.test:80 # resposta da porta 80! curl nginx.test:8080 # resposta da porta 8080! Esses dois blocos de server são como duas pessoas com um telefone fixo, esperando para responder quando uma requisição chega nos seu número. Seus números são indicados pelas diretivas listen.\nFora a diretiva listen, existe também a diretiva server_name. Considere o seguinte cenário de uma aplicação imaginária de administração de uma biblioteca:\nevents { } http { server { listen 80; server_name biblioteca.test; return 200 \"sua biblioteca local!\\n\"; } server { listen 80; server_name bibliotecario.biblioteca.test; return 200 \"bem vindo bibliotecário!\\n\"; } } Esse é um exemplo básico de um host virtual. Você está rodando duas aplicações separadas em diferentes server_name no mesmo servidor.\nSe você mandar a request para http://biblioteca.test você vai receber a resposta “sua biblioteca local!”. Se você mandar uma request para http://bibliotecario.biblioteca.test você vai receber “bem vindo bibliotecário!” como resposta.\ncurl http://biblioteca.test # sua biblioteca local! curl http://bibliotecario.biblioteca.test # bem vindo bibliotecário! Para fazer isso funcionar, você deve atualizar seu arquivo hosts para incluir esses dois domínios:\n192.168.0.100 biblioteca.test 192.168.0.100 bibliotecario.biblioteca.test Finalmente, a diretiva return é responsável por retornar uma resposta válida para o usuário. Essa diretiva recebe dois parâmetros: o status code e a string da mensagem para ser retornada.\nComo servir conteúdo estático usando NGINX Agora que você tem um bom entendimento de como escrever um arquivo de configuração básico para o NGINX, vamos melhorar a configuração para servir arquivos estáticos ao invés de respostas de texto\nPara servir conteúdo estático, primeiro você deve armazená-lo em algum lugar no seu servidor. Se você listar os arquivos e diretórios na raiz do seu servidor usando ls, você vai achar um diretório chamado /srv:\nls -lh / # lrwxrwxrwx 1 root root 7 Feb 3 00:00 bin -\u003e usr/bin # drwxr-xr-x 2 root root 4.0K Dec 31 10:25 boot # drwxr-xr-x 5 root root 340 Feb 24 23:48 dev # drwxr-xr-x 1 root root 4.0K Feb 6 00:26 docker-entrypoint.d # -rwxr-xr-x 1 root root 1.6K Feb 6 00:26 docker-entrypoint.sh # drwxr-xr-x 1 root root 4.0K Feb 24 23:55 etc # drwxr-xr-x 2 root root 4.0K Dec 31 10:25 home # lrwxrwxrwx 1 root root 7 Feb 3 00:00 lib -\u003e usr/lib # lrwxrwxrwx 1 root root 9 Feb 3 00:00 lib64 -\u003e usr/lib64 # drwxr-xr-x 2 root root 4.0K Feb 3 00:00 media # drwxr-xr-x 2 root root 4.0K Feb 3 00:00 mnt # drwxr-xr-x 2 root root 4.0K Feb 3 00:00 opt # dr-xr-xr-x 297 root root 0 Feb 24 23:48 proc # drwx------ 1 root root 4.0K Feb 25 00:00 root # drwxr-xr-x 1 root root 4.0K Feb 24 23:48 run # lrwxrwxrwx 1 root root 8 Feb 3 00:00 sbin -\u003e usr/sbin # drwxr-xr-x 2 root root 4.0K Feb 3 00:00 srv # dr-xr-xr-x 13 root root 0 Feb 24 23:48 sys # drwxrwxrwt 1 root root 4.0K Feb 24 23:55 tmp # drwxr-xr-x 1 root root 4.0K Feb 3 00:00 usr # drwxr-xr-x 1 root root 4.0K Feb 3 00:00 var Esse diretório /srv serve para armazenar conteúdo que deve ser servido pelo sistema. Agora vamos entrar nesse diretório e clonar o código do repositório desse tutorial:\ncd /srv git clone https://github.com/felprangel/exemplos-nginx.git Dentro do diretório exemplos-nginx deve ter um diretório chamado static-demo contendo quatro arquivos no total:\nls -lh /srv/exemplos-nginx/static-demo # -rw-r--r-- 1 root root 878 Feb 25 00:44 index.html # -rw-r--r-- 1 root root 46K Feb 25 00:44 mini.min.css # -rw-r--r-- 1 root root 50K Feb 25 00:44 nginx.jpg # -rw-r--r-- 1 root root 884 Feb 25 00:44 sobre.html Agora que você tem o conteúdo estático para ser servido, atualize sua configuração como a seguinte:\nevents { } http { server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; } } O código é quase o mesmo, mas a diretiva return foi substituída pela diretiva root. Essa diretiva é usada para declarar o diretório raiz de um site.\nEscrevendo root /srv/exemplos-nginx/static-demo; você está dizendo para o NGINX para procurar por arquivos para servir dentro do diretório /srv/exemplos-nginx/static-demo se qualquer request chegar no servidor. Como o NGINX é um servidor web, ele é inteligente o suficiente para servir o arquivo index.html por padrão.\nVamos ver se isso funciona. Teste e recarregue o arquivo de configuração atualizado e visite o servidor. Você deve ser recebido por um arquivo HTML quebrado:\nApesar do NGINX servir o arquivo index.html corretamente, julgando pela aparência dos 3 links de navegação, parece que o código CSS não está funcionando.\nVocê pode pensar que deve ter algo errado com o arquivo CSS. Mas na verdade, o problema está no arquivo de configuração.\nLidando com tipo de arquivo estático no NGINX Para debugar esse problema, envie uma request para o arquivo CSS no servidor:\ncurl -I http://nginx.test/mini.min.css # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Tue, 25 Feb 2025 00:47:08 GMT # Content-Type: text/plain # Content-Length: 46887 # Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT # Connection: keep-alive # ETag: \"67bd1272-b727\" # Accept-Ranges: bytes Preste atenção no Content-Type e veja como ele diz text/plain e não text/css. Isso significa que o NGINX está servindo esse arquivo como um texto plano ao invés de uma folha de estilos.\nApesar do NGINX ser esperto o suficiente para encontrar o arquivo index.html por padrão, ele pode ser bem bobinho quando o assunto é interpretar tipos de arquivos. Para resolver esse problema, atualize seu arquivo de configuração mais uma vez:\nevents { } http { types { text/html html; text/css css; } server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; } } A única mudança que fizemos no código é adicionar um novo contexto de types dentro do contexto de http. Como você deve ter adivinhado pelo nome, o contexto é usado para configurar os tipos.\nEscrevendo text/html html nesse contexto você está dizendo ao NGINX interpretar como text/html qualquer arquivo que termina com a extensão html\nVocê pode pensar que só configurar o tipo de arquivo CSS deve ser o suficiente, já que o HTML está sendo interpretado normalmente, mas não.\nSe você adicionar um contexto types na configuração, o NGINX fica ainda mais bobo e só interpreta os arquivos configurados por você. Então se você só definir o text/css css nesse contexto, o NGINX vai interpretar o arquivo html apenas como texto plano.\nValide e recarregue a nova configuração e visite o servidor novamente. Envie uma request para o arquivo CSS mais uma vez, e dessa vez o arquivo deve ser interpretado como um arquivo text/css\ncurl -I http://nginx.test/mini.min.css # Server: nginx/1.27.4 # Date: Tue, 25 Feb 2025 00:48:15 GMT # Content-Type: text/css # Content-Length: 46887 # Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT # Connection: keep-alive # ETag: \"67bd1272-b727\" # Accept-Ranges: bytes Visite o servidor para uma verificação visual, e o site deve estar mais agradável aos olhos dessa vez:\nComo incluir arquivos de configuração parciais Mapear os tipos de arquivo com o contexto types pode funcionar para projetos pequenos, mas para projetos grandes vira um pesadelo.\nO NGINX provê uma solução para esse problema. Se você listar os arquivos dentro do diretório /etc/nginx novamente, você vai ver um arquivo chamado mime.types.\nVamos ver o conteúdo desse arquivo:\ncat /etc/mime.types # types { # text/html html htm shtml; # text/css css; # text/xml xml; # image/gif gif; # image/jpeg jpeg jpg; # application/javascript js; # application/atom+xml atom; # application/rss+xml rss; # text/mathml mml; # text/plain txt; # text/vnd.sun.j2me.app-descriptor jad; # text/vnd.wap.wml wml; # text/x-component htc; # image/png png; # image/tiff tif tiff; # image/vnd.wap.wbmp wbmp; # image/x-icon ico; # image/x-jng jng; # image/x-ms-bmp bmp; # image/svg+xml svg svgz; # image/webp webp; # application/font-woff woff; # application/java-archive jar war ear; # application/json json; # application/mac-binhex40 hqx; # application/msword doc; # application/pdf pdf; # application/postscript ps eps ai; # application/rtf rtf; # application/vnd.apple.mpegurl m3u8; # application/vnd.ms-excel xls; # application/vnd.ms-fontobject eot; # application/vnd.ms-powerpoint ppt; # application/vnd.wap.wmlc wmlc; # application/vnd.google-earth.kml+xml kml; # application/vnd.google-earth.kmz kmz; # application/x-7z-compressed 7z; # application/x-cocoa cco; # application/x-java-archive-diff jardiff; # application/x-java-jnlp-file jnlp; # application/x-makeself run; # application/x-perl pl pm; # application/x-pilot prc pdb; # application/x-rar-compressed rar; # application/x-redhat-package-manager rpm; # application/x-sea sea; # application/x-shockwave-flash swf; # application/x-stuffit sit; # application/x-tcl tcl tk; # application/x-x509-ca-cert der pem crt; # application/x-xpinstall xpi; # application/xhtml+xml xhtml; # application/xspf+xml xspf; # application/zip zip; # application/octet-stream bin exe dll; # application/octet-stream deb; # application/octet-stream dmg; # application/octet-stream iso img; # application/octet-stream msi msp msm; # application/vnd.openxmlformats-officedocument.wordprocessingml.document docx; # application/vnd.openxmlformats-officedocument.spreadsheetml.sheet xlsx; # application/vnd.openxmlformats-officedocument.presentationml.presentation pptx; # audio/midi mid midi kar; # audio/mpeg mp3; # audio/ogg ogg; # audio/x-m4a m4a; # audio/x-realaudio ra; # video/3gpp 3gpp 3gp; # video/mp2t ts; # video/mp4 mp4; # video/mpeg mpeg mpg; # video/quicktime mov; # video/webm webm; # video/x-flv flv; # video/x-m4v m4v; # video/x-mng mng; # video/x-ms-asf asx asf; # video/x-ms-wmv wmv; # video/x-msvideo avi; # } O arquivo contém uma longa lista de tipos de arquivo e suas extensões. Para usar esse arquivo dentro do seu arquivo de configuração, atualize sua configuração como a seguinte:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; } } O antigo contexto types agora foi substituído pela nova diretiva include. Como o nome sugere, essa diretiva permite que o conteúdo de um arquivo seja incluso em outro.\nValide e recarregue o arquivo de configuração e mande uma request para o arquivo mini.min.css novamente:\ncurl -I http://nginx.test/mini.min.css # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Tue, 25 Feb 2025 00:56:40 GMT # Content-Type: text/css # Content-Length: 46887 # Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT # Connection: keep-alive # ETag: \"67bd1272-b727\" # Accept-Ranges: bytes Roteamento dinâmico no NGINX O arquivo de configuração que você escreveu na seção passada foi uma configuração muito simples de um servidor de conteúdo estático. Tudo que ele fazia era buscar o arquivo correspondente a URL que o cliente visita e retornar uma resposta.\nEntão se o usuário buscar por arquivos na raiz como index.html, sobre.html ou mini.min.css NGINX vai retornar o arquivo. Mas se você buscar uma rota como http://nginx.test/nada, ele vai responder com a página de 404 padrão:\nNessa seção do post, você vai aprender sobre o contexto location, variáveis, redirecionamentos, reescritas e a diretiva try_files. Vão ter novos projetos nessa seção, mas os conceitos que você vai aprender aqui vão ser necessários nas seções seguintes\nO arquivo de configuração vai mudar bastante nessa seção, então não esqueça de validar e recarregar o arquivo de configuração a cada atualização.\nCorrespondência de localização O primeiro conceito que vamos discutir nessa seção é o contexto location. Atualize sua configuração como a seguinte:\nevents { } http { server { listen 80; server_name nginx.test; location /machado { return 200 \"Bentinho.\\nCapitolina.\\n\"; } } } Nós substituímos a diretiva root com o novo contexto location. Esse contexto normalmente fica dentro de blocos de server. Podem existir múltiplos contextos location dentro de um contexto server.\nSe você enviar uma request para http://nginx.test/machado, você vai receber uma resposta 200 e uma lista de personagens do Machado de Assis.\ncurl -i http://nginx.test/machado # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Tue, 25 Feb 2025 02:07:58 GMT # Content-Type: text/plain # Content-Length: 22 # Connection: keep-alive # Bentinho. # Capitolina. Se você mandar uma request para http://nginx.test/machado-assis, você vai receber a mesma resposta:\ncurl -i http://nginx.test/machado-assis # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Tue, 25 Feb 2025 02:08:38 GMT # Content-Type: text/plain # Content-Length: 22 # Connection: keep-alive # Bentinho. # Capitolina. Isso acontece porque, escrevendo location /machado, você está dizendo para o NGINX para corresponder qualquer URI que comece com “machado”. Esse tipo de correspondência é chamado de correspondência por prefixo ou prefix match\nPara performar uma correspondência exata, você pode atualizar o código pelo seguinte:\nevents { } http { server { listen 80; server_name nginx.test; location = /machado { return 200 \"Bentinho.\\nCapitolina.\\n\"; } } } Adicionando uma sinal de igual = antes da URI vai instruir o NGINX para responder apenas a URL que tenha a correspondência exata. Agora se você mandar uma request para qualquer coisa que não seja /machado, você vai ter uma resposta 404.\nOutro tipo de correspondência no NGINX é a correspondência por regex. Usando esse tipo de correspondência você pode checar a URL com expressões regulares.\nevents { } http { server { listen 80; server_name nginx.test; location ~ /machado[0-9] { return 200 \"Bentinho.\\nCapitolina.\\n\"; } } } Substituindo o antigo = por um ~, você está dizendo ao NGINX para fazer uma correspondência por expressão regular. Fazendo essa config significar que o NGINX só vai responder se tiver um número depois da palavra “machado”\nUma correspondência por regex é case sensitive por padrão, o que significa que se você tornar uma letra maiúscula, o location não vai funcionar\nPara tornar isso em case insensitive, você precisa adicionar um * depois do ~.\nevents { } http { server { listen 80; server_name nginx.test; location ~* /machado[0-9] { return 200 \"Bentinho.\\nCapitolina.\\n\"; } } } O NGINX coloca prioridades nessas correspondências, e uma correspondência por regex tem mais prioridade do que uma correspondência por prefixo.\nevents { } http { server { listen 80; server_name nginx.test; location /Machado8 { return 200 \"correspondencia por prefixo.\\n\"; } location ~* /machado[0-9] { return 200 \"correspondencia por regex.\\n\"; } } } Ao enviar uma request para http://nginx.test/Machado8, você vai receber a seguinte resposta:\ncurl -i http://nginx.test/Machado8 # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Tue, 25 Feb 2025 02:09:45 GMT # Content-Type: text/plain # Content-Length: 27 # Connection: keep-alive # correspondencia por regex. Mas essa prioridade pode ser alterada. A maior prioridade de correspondência no NGINX é uma correspondência por prefixo preferencial. Para tornar uma correspondência por prefixo em um preferencial, você precisa adicionar o modificador ^~ antes da URI de localização:\nevents { } http { server { listen 80; server_name nginx.test; location ^~ /Machado8 { return 200 \"correspondencia por prefixo.\\n\"; } location ~* /machado[0-9] { return 200 \"correspondencia por regex.\\n\"; } } } Agora se você mandar uma request para http://nginx.test/Machado8, você vai ter a seguinte resposta:\ncurl -i http://nginx.test/Machado8 # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Wed, 26 Feb 2025 01:09:12 GMT # Content-Type: text/plain # Content-Length: 29 # Connection: keep-alive # correspondencia por prefixo. Dessa vez, a correspondência por prefixo ganhou. Então a lista de correspondências tem a seguinte ordem de prioridade:\nCorrespondência Modificador Exata = Prefixo preferencial ^~ REGEX ~ ou ~* Prefixo Nenhum Variáveis no NGINX Variáveis no NGINX são semelhantes a variáveis em outras linguagens de programação. A diretiva set pode ser usada para declarar novas variáveis em qualquer lugar no arquivo de configuração:\nset $ ; # set nome \"Felipe\" # set idade 20 # set esta_trabalhando true Variáveis podem ser de três tipos:\nString Inteiro Booleano Fora as variáveis que você declara, existem variáveis embutidas nos módulos do NGINX. Um índice em ordem alfabética dessas variáveis está disponível na documentação oficial.\nPara ver as variáveis em ação, atualize a configuração como a seguinte:\nevents { } http { server { listen 80; server_name nginx.test; return 200 \"Host - $host\\nURI - $uri\\nArgs - $args\\n\"; } } Fazendo uma request para o servidor, você deve receber uma resposta como a seguinte:\ncurl -i 'http://nginx.test/teste?parametro=valor' # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Wed, 26 Feb 2025 01:19:20 GMT # Content-Type: text/plain # Content-Length: 54 # Connection: keep-alive # Host - nginx.test # URI - /teste # Args - parametro=valor Como você pode ver, as variáveis $host e $uri tem o valor do endereço base acessado e a URI relativa ao endereço base, respectivamente. A variável $args, como pode ver, contém todos os query params.\nAo invés de printar a string literal dos query params, você pode acessar os valores individuais usando a variável $arg.\nevents { } http { server { listen 80; server_name nginx.test; set $nome $arg_nome; # $arg_ return 200 \"Nome - $nome\\n\"; } } Agora a resposta do servidor vai ser como o seguinte:\ncurl -i 'http://nginx.test?nome=felipe' Nome - felipe Redirecionamentos e Reescritas Um redirecionamento no NGINX é o mesmo de redirecionar em qualquer outra plataforma. Para demonstrar como os redirecionamentos funcionam, atualize sua configuração para ser algo como o seguinte:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; location = /pagina_index { return 307 /index.html; } location = /pagina_sobre { return 307 /sobre.html; } } } Agora se você mandar uma request para http://nginx.test/pagina_sobre, você vai ser redirecionado para http://nginx.test/sobre.html:\ncurl -I http://nginx.test/pagina_sobre # HTTP/1.1 307 Temporary Redirect # Server: nginx/1.27.4 # Date: Sun, 02 Mar 2025 00:22:15 GMT # Content-Type: text/html # Content-Length: 171 # Location: http://nginx.test/sobre.html # Connection: keep-alive Como pode ver, o servidor respondeu com um status code de 307 e o location indica a url http://nginx.test/sobre.html. Se você visitar http://nginx.test/pagina_sobre, você vai ver que a URL vai automaticamente mudar para http://nginx.test/sobre.html.\nUma diretiva rewrite, no entanto, funciona um pouco diferente. Ela muda a URI internamente, sem deixar o usuário saber. Para vê-lo em ação, atualize sua configuração como o seguinte:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; rewrite /pagina_index /index.html; rewrite /pagina_sobre /sobre.html; } } Agora se você mandar uma request para http://nginx.test/pagina_sobre, você vai ter uma resposta 200 e o código HTML para a página sobre.html na resposta:\ncurl -i http://nginx.test/pagina_sobre # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Sun, 02 Mar 2025 00:41:29 GMT # Content-Type: text/html # Content-Length: 884 # Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT # Connection: keep-alive # ETag: \"67bd1272-374\" # Accept-Ranges: bytes # \u003c!DOCTYPE html\u003e # # # # # # Exemplo site estático # # # # # # Index # Sobre # Nada # # # # esse é o arquivo de sobre.html # # # Agora se você visitar essa URI no browser, você vai ver a página sobre.html enquanto a URI não é alterada\nFora a parte de como se lida com a mudança de URI, tem outra diferença entre o redirecionamento e a reescrita. Quando uma reescrita acontece, o contexto server é recalculada pelo NGINX. Então uma reescrita é mais pesada do que um redirecionamento.\nComo tentar por múltiplos arquivos O conceito final que vou mostrar nessa seção é a diretiva try_files. Ao invés de responder com um único arquivo, a diretiva try_files permite você checar a existência de múltiplos arquivos.\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; try_files /nginx.jpg /nao_encontrado; location /nao_encontrado { return 404 \"Infelizmente não encontramos o que você pediu!\\n\"; } } } Como pode ver, uma nova diretiva try_files foi adicionada. Adicionando try_files /nginx.jpg /nao_encontrado; você está instruindo o NGINX para procurar por um arquivo chamado nginx.jpg na raiz sempre que uma request chegar. Se não existir, vá para a URI /not_found.\nO problema em escrever uma diretiva try_files dessa forma é que não importa qual URL você visite, contanto que a request seja recebida pelo servidor e a imagem nginx.jpg for encontrada no disco, NGINX vai retornarná-la.\nE é por isso que try_files é comumente utilizada com a variável $uri\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; try_files $uri /nao_encontrado; location /nao_encontrado { return 404 \"Infelizmente não encontramos o que você pediu!\\n\"; } } } Escrevendo try_files $uri /nao_encontrado; você está instruindo o NGINX para tentar pela URI requisitada pelo cliente primeiro. Se ele não encontrar o primeiro, ele vai tentar o próximo.\nAgora se você visitar http://nginx.test/index.html você deve receber a página index.html normalmente. O mesmo valo para a página sobre.html mas se você requisitar um arquivo que não existe, você via receber a resposta da rota /not_found\nUma coisa que talvez você já tenha percebido é que se você visitar a raiz do servidot http://nginx.test você vai receber a resposta 404.\nIsso acontece porque quando você está requisitando pela raiz do servidor, a variável $uri não corresponde a nenhum arquivo existente então o NGINX serve a URI de fallback. Se você quer consertar esse problema, atualize sua configuração como o seguinte:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; root /srv/exemplos-nginx/static-demo; try_files $uri $uri/ /nao_encontrado; location /nao_encontrado { return 404 \"Infelizmente não encontramos o que você pediu!\\n\"; } } } Ao escrever try_files $uri $uri/ /nao_encontrado; você está instruindo o NGINX para tentar pela URI requisitada primeiro. Se isso não funcionar então tentar a URI requisitada como um diretório, e quando o NGINX procurar por um diretório ele automaticamente começa a procurar por um arquivo index.html.\nO try_files é o tipo de diretiva que pode ser usada em um número de variações. Nas próximas seções você vai encontrar outras variações mas eu sugiro que você faça alguma pesquisa na internet sobre os diferentes usos da diretiva.\nLogs no NGINX Por padrão, os arquivos de log do NGINX são localizados dentro da pasta /var/log/nginx. Se você listar o conteúdo deste diretório, você via ver algo como o seguinte:\nls -lh /var/log/nginx/ # lrwxrwxrwx 1 root root 11 Feb 6 00:26 access.log -\u003e /dev/stdout # lrwxrwxrwx 1 root root 11 Feb 6 00:26 error.log -\u003e /dev/stderr Vamos começar limpando os dois arquivos\n# deleta os arquivos antigos sudo rm /var/log/nginx/access.log /var/log/nginx/error.log # criar os novos arquivos sudo touch /var/log/nginx/access.log /var/log/nginx/error.log # reabrir os arquivos de log sudo nginx -s reopen Se você não disparar um sinal de reopen pro NGINX, ele vai continuar escrevendo logs para as stream de logs antigas e os novos arquivos vão continuar vazios.\nAgora para fazer uma entrada no access log, mande uma request para o servidor.\ncurl -I http://nginx.test # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Mon, 03 Mar 2025 21:29:35 GMT # Content-Type: text/html # Content-Length: 878 # Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT # Connection: keep-alive # ETag: \"67bd1272-36e\" # Accept-Ranges: bytes sudo cat /var/log/nginx/access.log # 192.168.100.86 - - [03/Mar/2025:21:29:35 +0000] \"HEAD / HTTP/1.1\" 200 0 \"-\" \"curl/8.12.1\" Como pode ver, uma nova entrada foi adicionada no arquivo access.log. Qualquer request para o servidor vai ser logado nesse arquivo por padrão. Mas podemos mudar isso usando a diretiva access_log.\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; location / { return 200 \"Isso vai ser logado no arquivo padrão.\\n\"; } location = /admin { access_log /var/logs/nginx/admin.log; return 200 \"Isso vai ser logado em um arquivo separado.\\n\"; } location = /sem_log { access_log off; return 200 \"Isso não vai ser logado.\\n\"; } } } O primeiro access_log dentro do bloco location /admin instrui o NGINX para escrever qualquer access log dessa URI para o arquivo /var/logs/nginx/admin.log. O segundo dentro do location /sem_log desliga o access_log para essa location completamente.\nValide e recarregue a configuração. Agora se você enviar requests para essas URIs e inspecionar os arquivos de log, eles vão estar de acordo com o que foi configurado.\nO arquivo error.log, por outro lado, armazena os logs de falha. Para fazer uma entrada no error.log, você terá que fazer o NGINX crashar. Para fazê-lo, atualize sua configuração como a seguinte:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; return 200 \"...\" \"...\"; } } Como você sabe, a diretiva return só recebe dois parâmetros, mas aqui nós passamos três. Tente recarregar a configuração e você deve ser apresentado com uma mensagem de erro:\nsudo nginx -s reload # nginx: [emerg] invalid number of arguments in \"return\" directive in /etc/nginx/nginx.conf:14 Cheque o conteúdo do log de erro e a mensagem deve estar presente lá também:\nsudo cat /var/log/nginx/error.log # 2025/03/03 21:49:10 [emerg] 106#106: invalid number of arguments in \"return\" directive in /etc/nginx/nginx.conf:14 Mensagens de erro tem níveis. Uma entrada notice no log de erro é inofensivo, mas um emerg ou entrada de emergência deve ser resolvida logo.\nExistem oito níveis de mensagem de erro:\ndebug - Informações úteis de debug para determinar onde está o problema info - Mensagens informativas que não são necessárias de ler, mas são boas de se saber notice - Algor normal aconteceu e não vale basicamente nada warn - Algo inesperado aconteceu, mas não deve ser algo preocupante error - Alguma coisa não foi bem sucedida crit - Existem problemas críticos no funcionamento do servidor alert - Alguma ação é necessária emerg - O sistema está inutilizável e requer atenção imediata Por padrão, o NGINX grava todos os níveis de mensagem. Você pode sobrescrever esse comportamento usando a diretiva error_log. Se você quer determinar que o nível mínimo de erro deve ser warn, atualize sua configuração como a seguinte:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; error_log /var/log/error.log warn; return 200 \"...\" \"...\"; } } Para a maioria dos projetos, deixar a configuração de erro como está deve ser o suficiente. A única sugestão é setar o log mínimo de erro para o warn. Dessa forma você não tem de ver entradas desnecessárias no log de erro.\nDe toda forma, se quiser aprender mais sobre customizar os logs no NGINX, consulte a documentação oficial\nComo usar o NGINX como uma proxy reversa Quando configurado como uma proxy reversa, o NGINX fica entre o client e o servidor backend. O client manda requests para o NGINX, e então o NGINX passa a request para o backend.\nUma vez que o servidor backend terminar de processar a request, ele manda de volta para o NGINX. Então, o NGINX retorna a response para o client.\nDurante todo o processo, o client não tem ideia de quem está realmente processando a request. Parece complicado na hora de explicar, mas uma vez que você fizer, verá o quão fácil é fazer isso com o NGINX.\nVamos ver uma configuração básica e não muito prática de uma proxy reversa:\nevents { } http { include /etc/nginx/mime.types; server { listen 80; server_name nginx.test; location / { proxy_pass \"http://nginx.org/\"; } } } Agora se você visitar http://nginx.test, você vai ser recebido pelo nginx.org original, mesmo a URL estando inalterada.\nVocê também deve conseguir navegar pelo site, acessando cada página da documentação.\nComo pode ver, em um nível básico, a diretiva proxy_pass simplesmente passa a request do client para um servidor de terceiros e faz a proxy reversa da resposta pro client.\nNode com NGINX Agora você sabe como configurar um servidor básico de proxy reverso, você pode servir uma aplicação node usando o NGINX. Eu adicionei uma aplicação demo dentro do repositório que vem com esse artigo.\nEstou pressupondo que você tem experiência com Node.js e sabe como iniciar uma aplicação usando o PM2.\nSe você já clonou o repositório dentro do /srv/exemplos-nginx então o projeto node-js-demo deve estar disponível no diretório\nPara essa demo funcionar você vai precisar instalar o Node.js no seu servidor. Você pode fazer isso seguindo as instruções da documentação oficial\nEssa aplicação de demonstração é um servidor HTTP simples que responde com um status 200 e um payload JSON. Você pode iniciar a aplicação simplesmente executando node app.js mas uma maneira melhor de fazer isso é usando PM2.\nPara quem não sabe, PM2 é um gerenciador de projetos usado amplamente em projetos node em produção. Se quiser saber mais, esse link pode ajudar.\nInstale PM2 globalmente executando sudo npm install -g pm2. Depois da instalação, execute o seguinte comando dentro do diretório `/srv/exemplos-nginx/node-js-demo:\npm2 start app.js # [PM2] Spawning PM2 daemon with pm2_home=/root/.pm2 # [PM2] PM2 Successfully daemonized # [PM2] Starting /srv/exemplos-nginx/node-js-demo/app.js in fork_mode (1 instance) # [PM2] Done. # ┌────┬────────────────────┬──────────┬──────┬───────────┬──────────┬──────────┐ # │ id │ name │ mode │ ↺ │ status │ cpu │ memory │ # ├────┼────────────────────┼──────────┼──────┼───────────┼──────────┼──────────┤ # │ 0 │ app │ fork │ 0 │ online │ 0% │ 37.4mb │ # └────┴────────────────────┴──────────┴──────┴───────────┴──────────┴──────────┘ Você pode parar a aplicação rodando o comando pm2 stop app\nA aplicação deve estar rodando agora, mas não deve ser acessível do lado de fora do servidor. Para verificar se a aplicação está rodando, envie uma request para o http://localhost:3000 de dentro do seu servidor:\ncurl -i localhost:3000 # HTTP/1.1 200 OK # Content-Type: application/json # Date: Sun, 30 Mar 2025 12:57:28 GMT # Connection: keep-alive # Keep-Alive: timeout=5 # Transfer-Encoding: chunked # { \"status\": \"success\", \"message\": \"Você está aprendendo NGINX!\" } Se você recebeu uma resposta 200, então o servidor está funcionando normalmente. Para configurar o NGINX como uma proxy reversa, abra seu arquivo de configuração e atualize o conteúdo como o seguinte:\nevents { } http { server { listen 80; server_name nginx.test; location / { proxy_pass http://localhost:3000; } } } Nada novo para explicar aqui. Você só está passando a requisição recebido para o aplicação Node.js rodando na porta 3000. Agora se você enviar uma request para o servidor do lado de fora você vai receber uma resposta da seguinte forma:\ncurl -i http://nginx.test # HTTP/1.1 200 OK # Server: nginx/1.27.4 # Date: Sun, 30 Mar 2025 13:35:37 GMT # Content-Type: application/json # Transfer-Encoding: chunked # Connection: keep-alive # { \"status\": \"success\", \"message\": \"Você está aprendendo NGIN\" } Apesar disso funcionar para um servidor básico como esse, você pode ter que adicionar mais algumas diretivas para fazer isso funcionar em um cenário do mundo real dependendo dos requisitos da sua aplicação.\nPor exemplo, se sua aplicação lida com conexões de websocket, então você deve atualizar sua configuração como a seguinte:\nevents { } http { server { listen 80; server_name nginx.test; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; } } } A diretiva proxy_http_version define a versão do HTTP do servidor. Por padrão é 1.0, mas para usar websocket é necessário que seja pelo menos 1.1. A diretiva proxy_set_header é usada por definir um header no servidor. A sintaxe para essa diretiva é algo como:\nproxy_set_header Escrevendo proxy_set_header Upgrade $http_upgrade; você está instruindo NGINX para passar o valor da variável $http_upgrade como header chamado Upgrade, o mesmo pelo header Connection\nSe quiser saber mais sobre proxy de websocket, esse link da documentação oficial pode ajudar.\nDependendo dos headers que sua aplicação precisa, você pode ter que definir mais deles. Mas a configuração acima é comumente utilizada para servir aplicações Node.js\nComo usar o NGINX como um load balancer Graças ao design de proxy reversa do NGINX, você pode facilmente configurar ele como um load balancer.\nNo diretório /srv/exemplos-nginx/load-balancer-demo você deve encontrar uma demonstração que vamos utilizar nessa parte. Caso não tenha clonado o repositório nessa pasta ainda, agora é um bom momento para fazê-lo.\nNum cenário real, fazer um balanceamento de cargo é necessário em projetos de larga escala distribuídos em múltiplos servidores. Mas para essa simples demonstração, eu criei 3 servidores node simples que respondem como o número do servidor e o status code 200.\nPara essa demo funcionar você vai precisar instalar o Node.js no seu servidor. Você pode fazer isso seguindo as instruções da documentação oficial\nAlém disso, você também vai precisar do PM2 para rodar os servidores dessa demo.\nSe você não fez isso ainda, instale o PM2 com o comando npm install -g pm2. Depois da instalação acabar, execute o seguinte comando para executar os 3 servidores:\npm2 start /srv/exemplos-nginx/load-balancer-demo/server-1.js pm2 start /srv/exemplos-nginx/load-balancer-demo/server-2.js pm2 start /srv/exemplos-nginx/load-balancer-demo/server-3.js pm2 list # ┌────┬────────────────────┬──────────┬──────┬───────────┬──────────┬──────────┐ # │ id │ name │ mode │ ↺ │ status │ cpu │ memory │ # ├────┼────────────────────┼──────────┼──────┼───────────┼──────────┼──────────┤ # │ 0 │ server-1 │ fork │ 0 │ online │ 0% │ 37.4mb │ # │ 1 │ server-2 │ fork │ 0 │ online │ 0% │ 37.2mb │ # │ 2 │ server-3 │ fork │ 0 │ online │ 0% │ 37.1mb │ # └────┴────────────────────┴──────────┴──────┴───────────┴──────────┴──────────┘ Três servidores Node.js devem estar rodando em localhost:3001, localhost:3002, localhost:3003 respectivamente.\nAgora atualize sua configuração como a seguinte:\nevents { } http { upstream backend_servers { server localhost:3001; server localhost:3002; server localhost:3003; } server { listen 80; server_name nginx.test; location / { proxy_pass http://backend_servers; } } } A configuração dentro do contexto de server é o mesmo que já vimos antes. Mas o contexto upstream é novo. Um upstream no NGINX é uma coleção de servidores que pode ser tratado como apenas um backend.\nEntão os três servidores que inciamos usando PM2 pode ser colocado dentro de apenas um upstream e você deixar que o NGINX faça o balanceamento de carga entre eles.\nPara testar a configuração, você vai ter que mandar mais de uma request para o servidor. Você pode automatizar o processo usando um loop while em bash:\nwhile sleep 0.5; do curl http://nginx.test; done # resposta do servidor - 2. # resposta do servidor - 3. # resposta do servidor - 1. # resposta do servidor - 3. # resposta do servidor - 1. # resposta do servidor - 2. # resposta do servidor - 2. # resposta do servidor - 3. # resposta do servidor - 1. Você pode cancelar o loop pressionando Ctrl + C no seu teclado. Como pode ver das respostas do servidor, o NGINX faz o balanceamento de carga automaticamente.\nClaro, dependendo da escala do projeto, balancear a carga pode ser muito mais complicado que isso. Mas o objetivo desse artigo é te dar uma base. Você pode parar os servidores node executando pm2 stop all\nComo configurar processos worker e conexões worker Como mencionei em seções anteriores, o NGINX pode iniciar múltiplos processos worker, capazes de lidar com milhares de requests cada um.\nsudo systemctl status nginx # ● nginx.service - A high performance web server and a reverse proxy server # Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) # Active: active (running) since Sun 2025-03-23 08:33:11 UTC; 5h 45min ago # Docs: man:nginx(8) # Main PID: 3904 (nginx) # Tasks: 2 (limit: 1136) # Memory: 3.2M # CGroup: /system.slice/nginx.service # ├─ 3904 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; # └─16443 nginx: worker process Como pode ver, agora tem apenas um processo worker do NGINX no sistema. Entretanto, esse número pode ser alterado fazendo uma pequena mudança no arquivo de configuração.\nworker_processes 2; events { } http { server { listen 80; server_name nginx.test; return 200 \"Hello World :)\"; } } A diretiva worker_process escrita no contexto main é responsável por definir o número de processos worker para iniciar. Agora cheque o serviço do NGINX novamente e você deve ver dois processos worker:\nsudo systemctl status nginx # ● nginx.service - A high performance web server and a reverse proxy server # Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) # Active: active (running) since Sun 2025-03-23 08:33:11 UTC; 5h 54min ago # Docs: man:nginx(8) # Process: 22610 ExecReload=/usr/sbin/nginx -g daemon on; master_process on; -s reload (code=exited, status=0/SUCCESS) # Main PID: 3904 (nginx) # Tasks: 3 (limit: 1136) # Memory: 3.7M # CGroup: /system.slice/nginx.service # ├─ 3904 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; # ├─22611 nginx: worker process # └─22612 nginx: worker process Definindo o número de processos worker é fácil, mas determinar o número ideal de processos worker dá um pouco mais de trabalho.\nOs processos worker tem natureza assíncrona. Isso significa que eles vão processar as requests que chegam o mais rápido que o hardware pode.\nAgora considere que seu servidor rode em um processador com um core de processamento. Se você definir o número de processos worker para 1, aquele único processo vai utilizar 100% da capacidade do processador. Mas se você definir como 2, os 2 processos vão ser capazes de utilizar 50% do processador cada um. Então aumentar o número de processos worker não significa uma performance melhor.\nUma boa regra a se seguir é determinar o número de processos worker como o número de cores do seu processador.\nDeterminar o número de cores do processador no seu servidor é muito fácil no Linux.\nnproc # 1 Eu estou em uma máquina virtual de apenas um core, então o nproc identifica que tem apenas um core. Agora que você sabe o número de cores, tudo que resta fazer é definir o número na configuração.\nAté aí tudo bem, mas toda vez que você fizer upgrade no processador do servidor, vai ter de alterar a configuração manualmente.\nO NGINX provê uma forma melhor de lidar com esse problema. Você pode simplesmente definir o número de processos como auto e o NGINX vai definir o número de processos baseado no número de cores do processador automaticamente.\nworker_processes auto; events { } http { server { listen 80; server_name nginx.test; return 200 \"Hello World :)\"; } } Inspecione o processo do NGINX novamente:\nsudo systemctl status nginx # ● nginx.service - A high performance web server and a reverse proxy server # Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) # Active: active (running) since Sun 2025-03-23 08:33:11 UTC; 6h ago # Docs: man:nginx(8) # Process: 22610 ExecReload=/usr/sbin/nginx -g daemon on; master_process on; -s reload (code=exited, status=0/SUCCESS) # Main PID: 3904 (nginx) # Tasks: 2 (limit: 1136) # Memory: 3.2M # CGroup: /system.slice/nginx.service # ├─ 3904 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; # └─23659 nginx: worker process O número de processos worker está de volta em 1, isso porque esse é o mais otimizado nesse servidor.\nAlém dos processos worker também existem as conexões worker, indicando o número máximo de conexões que um único worker pode processar.\nAssim como o número de processos worker, esse número também está relacionado ao processador e ao número de arquivos que seu sistema operacional pode abrir por core.\nEncontrar esse número é bem fácil no Linux:\nulimit -n # 1024 Agora que temos esse número, tudo que nos resta é definir isso na configuração:\nworker_processes auto; events { worker_connections 1024; } http { server { listen 80; server_name nginx.test; return 200 \"Hello World :)\"; } } A diretiva worker_connections é responsável por definir o número de conexões worker em uma configuração. Essa também é a primeira vez que você está alterando o contexto events.\nEm uma seção anterior, eu mencionei que esse contexto é utilizado para definir valores usados pelo NGINX é um nível geral. A configuração de conexões worker é um exemplo desse tipo de configuração.\n","wordCount":"8012","inLanguage":"en","datePublished":"2025-03-31T00:00:00Z","dateModified":"2025-03-31T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.felpo.dev/posts/guia-b%C3%A1sico-de-nginx/"},"publisher":{"@type":"Organization","name":"Felpo Blog","logo":{"@type":"ImageObject","url":"https://blog.felpo.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.felpo.dev/ accesskey=h title="Felpo Blog (Alt + H)">Felpo Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Guia básico de NGINX</h1><div class=post-meta><span title='2025-03-31 00:00:00 +0000 UTC'>March 31, 2025</span></div></header><div class=post-content><p>Hoje vou fazer um dump de tudo que sei de NGINX, mostrando que não é difícil dar manutenção nos arquivos de configuração do seu servidor.</p><p>Depois de ler esse post você vai poder:</p><ul><li>Entender os arquivos de configuração do NGINX</li><li>Configurar o NGINX como um servidor web</li><li>Configurar o NGINX como um proxy reverso</li><li>Configurar o NGINX como um load balancer</li></ul><h1 id=índice>Índice<a hidden class=anchor aria-hidden=true href=#índice>#</a></h1><ul><li><a href=#introdu%C3%A7%C3%A3o-ao-nginx>Introdução ao NGINX</a></li><li><a href=#como-instalar-o-nginx>Como instalar o NGINX</a></li><li><a href=#introdu%C3%A7%C3%A3o-%C3%A0s-configura%C3%A7%C3%B5es-do-nginx>Introdução às configurações do NGINX</a></li><li><a href=#como-configurar-um-servidor-web-b%C3%A1sico>Como configurar um servidor web básico</a><ul><li><a href=#escrevendo-seu-primeiro-arquivo-de-configura%C3%A7%C3%A3o>Escrevendo seu primeiro arquivo de configuração</a></li><li><a href=#como-validar-e-recarregar-os-arquivos-de-configura%C3%A7%C3%A3o>Como validar e recarregar os arquivos de configuração</a></li><li><a href=#como-entender-as-diretivas-e-contextos-no-nginx>Como entender as diretivas e contextos no NGINX</a></li><li><a href=#como-servir-conte%C3%BAdo-est%C3%A1tico-usando-nginx>Como servir conteúdo estático usando NGINX</a></li><li><a href=#lidando-com-tipos-de-arquivo-est%C3%A1tico-no-nginx>Lidando com tipos de arquivo estático no NGINX</a></li><li><a href=#como-incluir-arquivos-de-configura%C3%A7%C3%A3o-parciais>Como incluir arquivos de configuração parciais</a></li></ul></li><li><a href=#roteamento-din%C3%A2mico-no-nginx>Roteamento dinâmico no NGINX</a><ul><li><a href=#correspond%C3%AAncia-de-localiza%C3%A7%C3%A3o>Correspondência de localização</a></li><li><a href=#vari%C3%A1veis-no-nginx>Variáveis no NGINX</a></li><li><a href=#redirecionamentos-e-reescritas>Redirecionamentos e reescritas</a></li><li><a href=#como-tentar-m%C3%BAltiplos-arquivos>Como tentar múltiplos arquivos</a></li></ul></li><li><a href=#logs-no-nginx>Logs no NGINX</a></li><li><a href=#como-usar-o-nginx-como-um-proxy-reverso>Como usar o NGINX como um proxy reverso</a><ul><li><a href=#node-com-nginx>Node com NGINX</a></li></ul></li><li><a href=#como-usar-o-nginx-como-um-load-balancer>Como usar o NGINX como um load balancer</a></li><li><a href=#como-configurar-processos-worker-e-conex%C3%B5es-worker>Como configurar processos worker e conexões worker</a></li></ul><h2 id=introdução-ao-nginx>Introdução ao NGINX<a hidden class=anchor aria-hidden=true href=#introdução-ao-nginx>#</a></h2><p>Apesar de ser mais conhecido como um servidor web, o NGINX é basicamente um servidor de <a href=https://pt.wikipedia.org/wiki/Proxy_reverso>proxy reverso</a>.</p><p>Quando uma request buscando conteúdo estático chega, o NGINX simplesmente responde com o arquivo, sem rodar nenhum processo adicional.
Isso não significa que o NGINX não consegue lidar com requests que precisam de um processamento por uma linguagem de programação dinâmica. Nesses casos, o NGINX simplesmente delega a tarefa para processos separados como o <a href=https://www.php.net/manual/en/install.fpm.php>PHP-FPM</a>, <a href=https://nodejs.org/pt>Node.js</a> ou <a href=https://www.python.org/>Python</a>. Então, quando o processo termina, o NGINX faz a proxy de resposta de volta pra o cliente.</p><h2 id=como-instalar-o-nginx>Como instalar o NGINX<a hidden class=anchor aria-hidden=true href=#como-instalar-o-nginx>#</a></h2><p>Em sistemas baseados em Debian/Ubuntu normalmente é apenas rodar:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo apt install nginx
</span></span></code></pre></div><p>Em caso de problemas você pode consultar a <a href=https://nginx.org/en/linux_packages.html>documentação oficial</a></p><p>Após a instalação, o NGINX deve estar registrado como um serviço do <code>systemd</code>. Para checar, execute o seguinte comando:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo systemctl status nginx
</span></span></code></pre></div><p>Se o serviço estiver rodando, você está pronto para começar. Caso contrário você pode iniciar o serviço com o seguinte comando:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo systemctl start nginx
</span></span></code></pre></div><p>Por último, para um verificação visual de que tudo está rodando e funcionando como deveria, abra o <code>localhost</code> no seu navegador e você deve conseguir ver a tela inicial do NGINX</p><p><img alt=image loading=lazy src=/images/Pasted%20image%2020250214230141.png></p><p>NGINX normalmente é instalado no diretório <code>/etc/nginx</code> e a maioria do nosso trabalho nas seções que estão por vir vão ser feitas aqui.</p><p>Parabéns! Agora você tem um NGINX rodando na sua máquina. Agora é hora de pular de cabeça no NGINX.</p><h2 id=introdução-as-configurações-do-nginx>Introdução as configurações do NGINX<a hidden class=anchor aria-hidden=true href=#introdução-as-configurações-do-nginx>#</a></h2><p>Como um servidor web, o trabalho do NGINX é servir conteúdo estático aos clientes. Mas como esse conteúdo vai ser servido é normalmente controlado por arquivos de configuração.</p><p>Os arquivos de configuração do NGINX acabam com a extensão <code>.conf</code> e normalmente estão dentro da pasta <code>/etc/nginx</code>. Vamos começar entrando nesse diretório e listando todos os arquivos:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cd /etc/nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ls -lh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x 1 root root 4.0K Feb 24 23:48 conf.d</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root 1007 Feb  5 11:06 fastcgi_params</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root 5.3K Feb  5 11:06 mime.types</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx 1 root root   22 Feb  5 14:26 modules -&gt; /usr/lib/nginx/modules</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root  648 Feb  5 14:26 nginx.conf</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root  636 Feb  5 11:06 scgi_params</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root  664 Feb  5 11:06 uwsgi_params</span>
</span></span></code></pre></div><p>Entre esses arquivos, deve ter um chamado <em>nginx.conf</em>. Esse é o arquivo de configuração principal do NGINX. Você pode dar uma olhada no conteúdo do arquivo com o <code>cat</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cat nginx.conf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># user  nginx;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># worker_processes  auto;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># error_log  /var/log/nginx/error.log notice;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># pid        /var/run/nginx.pid;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># events {</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     worker_connections  1024;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># }</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># http {</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     include       /etc/nginx/mime.types;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     default_type  application/octet-stream;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     log_format  main  &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#                       &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#                       &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     access_log  /var/log/nginx/access.log  main;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     sendfile        on;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     #tcp_nopush     on;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     keepalive_timeout  65;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     #gzip  on;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     include /etc/nginx/conf.d/*.conf;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># }</span>
</span></span></code></pre></div><p>Tentar entender esse arquivo nesse estado é um pesadelo. Vamos renomeá-lo e criar um novo arquivo vazio:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># renomeia o arquivo</span>
</span></span><span style=display:flex><span>sudo mv nginx.conf nginx.conf.backup
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># cria um novo arquivo</span>
</span></span><span style=display:flex><span>sudo touch nginx.conf
</span></span></code></pre></div><p><em>Não é recomendado</em> editar o arquivo <code>nginx.conf</code> original a não ser que você saiba exatamente o que você está fazendo. Para fins educativos, estamos renomeando, mas depois, você vai ver como deveria configurar um servidor em um caso real.</p><h2 id=como-configurar-um-servidor-web-básico>Como configurar um servidor web básico<a hidden class=anchor aria-hidden=true href=#como-configurar-um-servidor-web-básico>#</a></h2><p>Nessa seção, vamos colocar a mão na masse e configurar um simples servidor web estático. O intuito dessa seção é introduzir você para a sintaxe fundamental dos conceitos dos arquivos de configuração do NGINX.</p><h3 id=escrevendo-seu-primeiro-arquivo-de-configuração>Escrevendo seu primeiro arquivo de configuração<a hidden class=anchor aria-hidden=true href=#escrevendo-seu-primeiro-arquivo-de-configuração>#</a></h3><p>Comece abrindo seu recém criado <code>nginx.conf</code> usando seu editor de texto favorito, pra esse exemplo, vou usar o nano:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo nano /etc/nginx/nginx.conf
</span></span></code></pre></div><p>Depois de abrir o arquivo, atualize seu conteúdo para que fique dessa forma:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {
}

http {
    server {
        listen 80;
        server_name nginx.test;

        return 200 &#34;Hello World!\n&#34;;
    }
}
</code></pre><p>Se você tem experiência na construção de API REST você deve ter deduzido da linha com <code>return 200 ""Hello World!\n";</code> que o servidor foi configurado para responder com status code de 200 e a mensagem &ldquo;Hello World!&rdquo;</p><p>Não se preocupe se você não entendeu nada além disso nesse momento. Eu vou explicar esse arquivo linha a linha, mas primeiro, vamos ver essa configuração em ação.</p><h3 id=como-validar-e-recarregar-os-arquivos-de-configuração>Como validar e recarregar os arquivos de configuração<a hidden class=anchor aria-hidden=true href=#como-validar-e-recarregar-os-arquivos-de-configuração>#</a></h3><p>Depois de escrever um novo arquivo de configuração ou atualizar um antigo, a primeira coisa a se fazer é checar se existe algum erro de sintaxe no arquivo. O binário do <code>nginx</code> inclui a opção <code>-t</code> que faz exatamente isso</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo nginx -t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span>
</span></span><span style=display:flex><span><span style=color:#75715e># nginx: configuration file /etc/nginx/nginx.conf test is successful</span>
</span></span></code></pre></div><p>Se exite algum erro de sintaxe, o comando vai te alertar sobre ele, incluindo o número da linha.</p><p>Apesar do arquivo de configuração estar certo, o NGINX não vai usá-lo. Do jeito que o NGINX funciona ele lê o arquivo de configuração uma vez e continua rodando baseado nessa primeira leitura.</p><p>Se você atualizar o arquivo de configuração, então você precisa instruir o NGINX explicitamente para recarregar o arquivo de configuração.
Existem duas formas de fazer isso:</p><ul><li>Você pode reiniciar o serviço do NGINX executando o comando <code>sudo systemctl restart nginx</code></li><li>Você pode mandar um sinal de <code>reload</code> para o NGINX executando o comando <code>sudo nginx -s reload</code></li></ul><p>O <code>-s</code> é usado para enviar vários sinais para o NGINX. O sinais disponíveis são <code>stop</code>, <code>quit</code>, <code>reload</code>, e <code>reopen</code>. Entre os dois jeitos de atualizar o arquivo, eu prefiro o segundo, simplesmente por que é menos coisas para digitar.</p><p>uma ver que você tenha recarregado o arquivo de configuração rodando o comando <code>nginx -s reload</code>, você pode ver isso em ação fazendo uma request get para o servidor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Mon, 24 Feb 2025 23:56:44 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 13</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Hello World!</span>
</span></span></code></pre></div><p>O servidor está respondendo com um status code de 200 e a mensagem esperada. Parabéns por chegar tão longe! Agora é hora de algumas explicações.</p><h3 id=como-entender-as-diretivas-e-contextos-no-nginx>Como entender as diretivas e contextos no NGINX<a hidden class=anchor aria-hidden=true href=#como-entender-as-diretivas-e-contextos-no-nginx>#</a></h3><p>As poucas linhas de código que você escreveu até agora, apesar de parecerem simples, introduzem duas das mais importantes terminologias dos arquivos de configuração do NGINX. Elas são <em>diretivas</em> e <em>contextos</em>.</p><p>Tecnicamente, tudo dentro de um arquivo de configuração do NGINX é uma <em>diretiva</em>. Diretivas são de dois tipos:</p><ul><li>Diretivas simples</li><li>Diretivas de bloco</li></ul><p>Uma diretiva simples consiste do nome da diretiva e os parâmetros delimitados por espaços, como <code>listen</code>, <code>return</code> e outros.
Diretivas simples são terminadas por ponto e vírgula.</p><p>Diretivas de bloco são similares das diretivas simples, mas ao invés de terminar com ponto e vírgula, eles terminam com um par de chaves <code>{}</code> fechando instruções adicionais.</p><p>Uma diretiva de bloco capaz de conter outras diretivas dentro é chamada de contexto, que são os <code>events</code>, <code>http</code> e por aí vai.
Existem quatro contextos principais no NGINX:</p><ul><li><code>events {}</code> - O contexto de <code>events</code> é usado para definir a configuração global de como o NGINX vai lidar com as requests de um modo geral. Só pode existir um contexto de <code>events</code> em um arquivo de configuração válido.</li><li><code>http {}</code> - Evidente pelo nome, o contexto de <code>http</code> é usado para definir a configuração de como o servidor vai lidar com requests HTTP e HTTPS, especificamente. Só pode existir um contexto <code>http</code> em um arquivo de configuração válido.</li><li><code>server {}</code> - O contexto de <code>server</code> é aninhado dentro do contexto de <code>http</code> e usado para configurar servidores virtuais específicos em apenas um host. Podem existir vários contexto de <code>server</code> dentro de um contexto de <code>http</code>. Cada contexto de <code>server</code> é considerado um host virtual.</li><li><code>main</code> - O contexto <code>main</code> é o próprio arquivo de configuração. Qualquer coisa escrita fora dos três contextos mencionados anteriormente está no contexto <code>main</code>.</li></ul><p>Você pode considerar contextos do NGINX como escopos em outras linguagens de programação. Existe também uma certa forma de herança entre eles. Você pode encontrar um <a href=https://nginx.org/en/docs/dirindex.html>índice de diretivas em ordem alfabética</a> na documentação oficial.</p><p>Eu mencionei que podem existir múltiplos contextos de <code>server</code> no arquivo de configuração. Mas quando a request chega no servidor, como o NGINX sabe qual dos contextos deve lidar com a request?</p><p>A diretiva de <code>listen</code> é um dos jeitos de identificar o contexto <code>server</code> correto na configuração. Considere o seguinte cenário:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {
}

http {
    server {
        listen 80;
        server_name nginx.test;

        return 200 &#34;resposta da porta 80!\n&#34;;
    }


    server {
        listen 8080;
        server_name nginx.test;

        return 200 &#34;resposta da porta 8080!\n&#34;;
    }
}
</code></pre><p>Agora se você mandar uma request para <code>http://nginx.test:80</code> você vai receber &ldquo;resposta da porta 80!&rdquo; como resposta. E se você mandar uma request para <code>http://nginx.test:8080</code> você vai receber &ldquo;resposta da porta 8080!&rdquo; como uma resposta:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl nginx.test:80
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta da porta 80!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl nginx.test:8080
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta da porta 8080!</span>
</span></span></code></pre></div><p>Esses dois blocos de <code>server</code> são como duas pessoas com um telefone fixo, esperando para responder quando uma requisição chega nos seu número. Seus números são indicados pelas diretivas <code>listen</code>.</p><p>Fora a diretiva <code>listen</code>, existe também a diretiva <code>server_name</code>. Considere o seguinte cenário de uma aplicação imaginária de administração de uma biblioteca:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {
}

http {
    server {
        listen 80;
        server_name biblioteca.test;

        return 200 &#34;sua biblioteca local!\n&#34;;
    }


    server {
        listen 80;
        server_name bibliotecario.biblioteca.test;

        return 200 &#34;bem vindo bibliotecário!\n&#34;;
    }
}
</code></pre><p>Esse é um exemplo básico de um host virtual. Você está rodando duas aplicações separadas em diferentes <code>server_name</code> no mesmo servidor.</p><p>Se você mandar a request para <code>http://biblioteca.test</code> você vai receber a resposta &ldquo;sua biblioteca local!&rdquo;. Se você mandar uma request para <code>http://bibliotecario.biblioteca.test</code> você vai receber &ldquo;bem vindo bibliotecário!&rdquo; como resposta.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl http://biblioteca.test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># sua biblioteca local!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl http://bibliotecario.biblioteca.test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># bem vindo bibliotecário!</span>
</span></span></code></pre></div><p>Para fazer isso funcionar, você deve atualizar seu arquivo <code>hosts</code> para incluir esses dois domínios:</p><pre tabindex=0><code>192.168.0.100 biblioteca.test
192.168.0.100 bibliotecario.biblioteca.test
</code></pre><p>Finalmente, a diretiva <code>return</code> é responsável por retornar uma resposta válida para o usuário. Essa diretiva recebe dois parâmetros: o status code e a string da mensagem para ser retornada.</p><h3 id=como-servir-conteúdo-estático-usando-nginx>Como servir conteúdo estático usando NGINX<a hidden class=anchor aria-hidden=true href=#como-servir-conteúdo-estático-usando-nginx>#</a></h3><p>Agora que você tem um bom entendimento de como escrever um arquivo de configuração básico para o NGINX, vamos melhorar a configuração para servir arquivos estáticos ao invés de respostas de texto</p><p>Para servir conteúdo estático, primeiro você deve armazená-lo em algum lugar no seu servidor. Se você listar os arquivos e diretórios na raiz do seu servidor usando <code>ls</code>, você vai achar um diretório chamado <code>/srv</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ls -lh /
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx   1 root root    7 Feb  3 00:00 bin -&gt; usr/bin</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   2 root root 4.0K Dec 31 10:25 boot</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   5 root root  340 Feb 24 23:48 dev</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   1 root root 4.0K Feb  6 00:26 docker-entrypoint.d</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rwxr-xr-x   1 root root 1.6K Feb  6 00:26 docker-entrypoint.sh</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   1 root root 4.0K Feb 24 23:55 etc</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   2 root root 4.0K Dec 31 10:25 home</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx   1 root root    7 Feb  3 00:00 lib -&gt; usr/lib</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx   1 root root    9 Feb  3 00:00 lib64 -&gt; usr/lib64</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   2 root root 4.0K Feb  3 00:00 media</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   2 root root 4.0K Feb  3 00:00 mnt</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   2 root root 4.0K Feb  3 00:00 opt</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dr-xr-xr-x 297 root root    0 Feb 24 23:48 proc</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwx------   1 root root 4.0K Feb 25 00:00 root</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   1 root root 4.0K Feb 24 23:48 run</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx   1 root root    8 Feb  3 00:00 sbin -&gt; usr/sbin</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   2 root root 4.0K Feb  3 00:00 srv</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dr-xr-xr-x  13 root root    0 Feb 24 23:48 sys</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxrwxrwt   1 root root 4.0K Feb 24 23:55 tmp</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   1 root root 4.0K Feb  3 00:00 usr</span>
</span></span><span style=display:flex><span><span style=color:#75715e># drwxr-xr-x   1 root root 4.0K Feb  3 00:00 var</span>
</span></span></code></pre></div><p>Esse diretório <code>/srv</code> serve para armazenar conteúdo que deve ser servido pelo sistema. Agora vamos entrar nesse diretório e clonar o código do repositório desse tutorial:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cd /srv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>git clone https://github.com/felprangel/exemplos-nginx.git
</span></span></code></pre></div><p>Dentro do diretório <code>exemplos-nginx</code> deve ter um diretório chamado <code>static-demo</code> contendo quatro arquivos no total:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ls -lh /srv/exemplos-nginx/static-demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root 878 Feb 25 00:44 index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root 46K Feb 25 00:44 mini.min.css</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root 50K Feb 25 00:44 nginx.jpg</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 root root 884 Feb 25 00:44 sobre.html</span>
</span></span></code></pre></div><p>Agora que você tem o conteúdo estático para ser servido, atualize sua configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {
}

http {
    server {
        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;
    }
}
</code></pre><p>O código é quase o mesmo, mas a diretiva <code>return</code> foi substituída pela diretiva <code>root</code>. Essa diretiva é usada para declarar o diretório raiz de um site.</p><p>Escrevendo <code>root /srv/exemplos-nginx/static-demo;</code> você está dizendo para o NGINX para procurar por arquivos para servir dentro do diretório <code>/srv/exemplos-nginx/static-demo</code> se qualquer request chegar no servidor. Como o NGINX é um servidor web, ele é inteligente o suficiente para servir o arquivo <code>index.html</code> por padrão.</p><p>Vamos ver se isso funciona. Teste e recarregue o arquivo de configuração atualizado e visite o servidor. Você deve ser recebido por um arquivo HTML quebrado:</p><p><img alt=image loading=lazy src=/images/Pasted%20image%2020250216172339.png></p><p>Apesar do NGINX servir o arquivo <code>index.html</code> corretamente, julgando pela aparência dos 3 links de navegação, parece que o código CSS não está funcionando.</p><p>Você pode pensar que deve ter algo errado com o arquivo CSS. Mas na verdade, o problema está no arquivo de configuração.</p><h3 id=lidando-com-tipo-de-arquivo-estático-no-nginx>Lidando com tipo de arquivo estático no NGINX<a hidden class=anchor aria-hidden=true href=#lidando-com-tipo-de-arquivo-estático-no-nginx>#</a></h3><p>Para debugar esse problema, envie uma request para o arquivo CSS no servidor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -I http://nginx.test/mini.min.css
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Tue, 25 Feb 2025 00:47:08 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 46887</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ETag: &#34;67bd1272-b727&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Accept-Ranges: bytes</span>
</span></span></code></pre></div><p>Preste atenção no <code>Content-Type</code> e veja como ele diz <code>text/plain</code> e não <code>text/css</code>. Isso significa que o NGINX está servindo esse arquivo como um texto plano ao invés de uma folha de estilos.</p><p>Apesar do NGINX ser esperto o suficiente para encontrar o arquivo <code>index.html</code> por padrão, ele pode ser bem bobinho quando o assunto é interpretar tipos de arquivos. Para resolver esse problema, atualize seu arquivo de configuração mais uma vez:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {
}

http {
    types {
        text/html html;
        text/css css;
    }

    server {
        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;
    }
}
</code></pre><p>A única mudança que fizemos no código é adicionar um novo contexto de <code>types</code> dentro do contexto de <code>http</code>. Como você deve ter adivinhado pelo nome, o contexto é usado para configurar os tipos.</p><p>Escrevendo <code>text/html html</code> nesse contexto você está dizendo ao NGINX interpretar como <code>text/html</code> qualquer arquivo que termina com a extensão <code>html</code></p><p>Você pode pensar que só configurar o tipo de arquivo CSS deve ser o suficiente, já que o HTML está sendo interpretado normalmente, mas não.</p><p>Se você adicionar um contexto <code>types</code> na configuração, o NGINX fica ainda mais bobo e só interpreta os arquivos configurados por você. Então se você só definir o <code>text/css css</code> nesse contexto, o NGINX vai interpretar o arquivo html apenas como texto plano.</p><p>Valide e recarregue a nova configuração e visite o servidor novamente. Envie uma request para o arquivo CSS mais uma vez, e dessa vez o arquivo deve ser interpretado como um arquivo <em>text/css</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -I http://nginx.test/mini.min.css
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Tue, 25 Feb 2025 00:48:15 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/css</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 46887</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ETag: &#34;67bd1272-b727&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Accept-Ranges: bytes</span>
</span></span></code></pre></div><p>Visite o servidor para uma verificação visual, e o site deve estar mais agradável aos olhos dessa vez:</p><p><img alt=image loading=lazy src=/images/Pasted%20image%2020250216175258.png></p><h3 id=como-incluir-arquivos-de-configuração-parciais>Como incluir arquivos de configuração parciais<a hidden class=anchor aria-hidden=true href=#como-incluir-arquivos-de-configuração-parciais>#</a></h3><p>Mapear os tipos de arquivo com o contexto <code>types</code> pode funcionar para projetos pequenos, mas para projetos grandes vira um pesadelo.</p><p>O NGINX provê uma solução para esse problema. Se você listar os arquivos dentro do diretório <code>/etc/nginx</code> novamente, você vai ver um arquivo chamado <code>mime.types</code>.</p><p>Vamos ver o conteúdo desse arquivo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/mime.types
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># types {</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/html                             html htm shtml;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/css                              css;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/xml                              xml;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/gif                             gif;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/jpeg                            jpeg jpg;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/javascript                js;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/atom+xml                  atom;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/rss+xml                   rss;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/mathml                           mml;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/plain                            txt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/vnd.sun.j2me.app-descriptor      jad;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/vnd.wap.wml                      wml;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     text/x-component                      htc;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/png                             png;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/tiff                            tif tiff;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/vnd.wap.wbmp                    wbmp;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/x-icon                          ico;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/x-jng                           jng;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/x-ms-bmp                        bmp;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/svg+xml                         svg svgz;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     image/webp                            webp;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/font-woff                 woff;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/java-archive              jar war ear;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/json                      json;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/mac-binhex40              hqx;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/msword                    doc;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/pdf                       pdf;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/postscript                ps eps ai;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/rtf                       rtf;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.apple.mpegurl         m3u8;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.ms-excel              xls;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.ms-fontobject         eot;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.ms-powerpoint         ppt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.wap.wmlc              wmlc;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.google-earth.kml+xml  kml;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.google-earth.kmz      kmz;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-7z-compressed           7z;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-cocoa                   cco;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-java-archive-diff       jardiff;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-java-jnlp-file          jnlp;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-makeself                run;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-perl                    pl pm;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-pilot                   prc pdb;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-rar-compressed          rar;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-redhat-package-manager  rpm;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-sea                     sea;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-shockwave-flash         swf;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-stuffit                 sit;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-tcl                     tcl tk;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-x509-ca-cert            der pem crt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/x-xpinstall               xpi;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/xhtml+xml                 xhtml;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/xspf+xml                  xspf;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/zip                       zip;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/octet-stream              bin exe dll;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/octet-stream              deb;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/octet-stream              dmg;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/octet-stream              iso img;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/octet-stream              msi msp msm;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.openxmlformats-officedocument.wordprocessingml.document    docx;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.openxmlformats-officedocument.spreadsheetml.sheet          xlsx;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     application/vnd.openxmlformats-officedocument.presentationml.presentation  pptx;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     audio/midi                            mid midi kar;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     audio/mpeg                            mp3;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     audio/ogg                             ogg;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     audio/x-m4a                           m4a;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     audio/x-realaudio                     ra;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/3gpp                            3gpp 3gp;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/mp2t                            ts;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/mp4                             mp4;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/mpeg                            mpeg mpg;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/quicktime                       mov;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/webm                            webm;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/x-flv                           flv;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/x-m4v                           m4v;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/x-mng                           mng;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/x-ms-asf                        asx asf;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/x-ms-wmv                        wmv;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     video/x-msvideo                       avi;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># }</span>
</span></span></code></pre></div><p>O arquivo contém uma longa lista de tipos de arquivo e suas extensões. Para usar esse arquivo dentro do seu arquivo de configuração, atualize sua configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {
}

http {

    include /etc/nginx/mime.types;

    server {
        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;
    }
}
</code></pre><p>O antigo contexto <code>types</code> agora foi substituído pela nova diretiva <code>include</code>. Como o nome sugere, essa diretiva permite que o conteúdo de um arquivo seja incluso em outro.</p><p>Valide e recarregue o arquivo de configuração e mande uma request para o arquivo <code>mini.min.css</code> novamente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -I http://nginx.test/mini.min.css
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Tue, 25 Feb 2025 00:56:40 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/css</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 46887</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ETag: &#34;67bd1272-b727&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Accept-Ranges: bytes</span>
</span></span></code></pre></div><h2 id=roteamento-dinâmico-no-nginx>Roteamento dinâmico no NGINX<a hidden class=anchor aria-hidden=true href=#roteamento-dinâmico-no-nginx>#</a></h2><p>O arquivo de configuração que você escreveu na seção passada foi uma configuração muito simples de um servidor de conteúdo estático. Tudo que ele fazia era buscar o arquivo correspondente a URL que o cliente visita e retornar uma resposta.</p><p>Então se o usuário buscar por arquivos na raiz como <code>index.html</code>, <code>sobre.html</code> ou <code>mini.min.css</code> NGINX vai retornar o arquivo. Mas se você buscar uma rota como <a href=http://nginx.test/nada>http://nginx.test/nada</a>, ele vai responder com a página de 404 padrão:</p><p><img alt=image loading=lazy src=/images/Pasted%20image%2020250219225145.png></p><p>Nessa seção do post, você vai aprender sobre o contexto <code>location</code>, variáveis, redirecionamentos, reescritas e a diretiva <code>try_files</code>. Vão ter novos projetos nessa seção, mas os conceitos que você vai aprender aqui vão ser necessários nas seções seguintes</p><p>O arquivo de configuração vai mudar bastante nessa seção, então não esqueça de validar e recarregar o arquivo de configuração a cada atualização.</p><h3 id=correspondência-de-localização>Correspondência de localização<a hidden class=anchor aria-hidden=true href=#correspondência-de-localização>#</a></h3><p>O primeiro conceito que vamos discutir nessa seção é o contexto <code>location</code>. Atualize sua configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        location /machado {
            return 200 &#34;Bentinho.\nCapitolina.\n&#34;;
        }
    }
}
</code></pre><p>Nós substituímos a diretiva <code>root</code> com o novo contexto <code>location</code>. Esse contexto normalmente fica dentro de blocos de <code>server</code>. Podem existir múltiplos contextos <code>location</code> dentro de um contexto <code>server</code>.</p><p>Se você enviar uma request para <a href=http://nginx.test/machado>http://nginx.test/machado</a>, você vai receber uma resposta 200 e uma lista de personagens do Machado de Assis.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test/machado
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Tue, 25 Feb 2025 02:07:58 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 22</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Bentinho.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Capitolina.</span>
</span></span></code></pre></div><p>Se você mandar uma request para <a href=http://nginx.test/machado-assis>http://nginx.test/machado-assis</a>, você vai receber a mesma resposta:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test/machado-assis
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Tue, 25 Feb 2025 02:08:38 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 22</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Bentinho.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Capitolina.</span>
</span></span></code></pre></div><p>Isso acontece porque, escrevendo <code>location /machado</code>, você está dizendo para o NGINX para corresponder qualquer URI que comece com &ldquo;machado&rdquo;. Esse tipo de correspondência é chamado de <em>correspondência por prefixo</em> ou <em>prefix match</em></p><p>Para performar uma <em>correspondência exata</em>, você pode atualizar o código pelo seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        location = /machado {
            return 200 &#34;Bentinho.\nCapitolina.\n&#34;;
        }
    }
}
</code></pre><p>Adicionando uma sinal de igual <code>=</code> antes da URI vai instruir o NGINX para responder apenas a URL que tenha a correspondência exata. Agora se você mandar uma request para qualquer coisa que não seja <code>/machado</code>, você vai ter uma resposta 404.</p><p>Outro tipo de correspondência no NGINX é a <em>correspondência por regex</em>. Usando esse tipo de correspondência você pode checar a URL com expressões regulares.</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        location ~ /machado[0-9] {
            return 200 &#34;Bentinho.\nCapitolina.\n&#34;;
        }
    }
}
</code></pre><p>Substituindo o antigo <code>=</code> por um <code>~</code>, você está dizendo ao NGINX para fazer uma correspondência por expressão regular. Fazendo essa config significar que o NGINX só vai responder se tiver um número depois da palavra &ldquo;machado&rdquo;</p><p>Uma correspondência por regex é case sensitive por padrão, o que significa que se você tornar uma letra maiúscula, o <code>location</code> não vai funcionar</p><p>Para tornar isso em case insensitive, você precisa adicionar um <code>*</code> depois do <code>~</code>.</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        location ~* /machado[0-9] {
            return 200 &#34;Bentinho.\nCapitolina.\n&#34;;
        }
    }
}
</code></pre><p>O NGINX coloca prioridades nessas correspondências, e uma correspondência por regex tem mais prioridade do que uma correspondência por prefixo.</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        location /Machado8 {
            return 200 &#34;correspondencia por prefixo.\n&#34;;
        }

        location ~* /machado[0-9] {
            return 200 &#34;correspondencia por regex.\n&#34;;
        }
    }

}
</code></pre><p>Ao enviar uma request para <a href=http://nginx.test/Machado8>http://nginx.test/Machado8</a>, você vai receber a seguinte resposta:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test/Machado8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Tue, 25 Feb 2025 02:09:45 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 27</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># correspondencia por regex.</span>
</span></span></code></pre></div><p>Mas essa prioridade pode ser alterada. A maior prioridade de correspondência no NGINX é uma <em>correspondência por prefixo preferencial</em>. Para tornar uma correspondência por prefixo em um preferencial, você precisa adicionar o modificador <code>^~</code> antes da URI de localização:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        location ^~ /Machado8 {
            return 200 &#34;correspondencia por prefixo.\n&#34;;
        }

        location ~* /machado[0-9] {
            return 200 &#34;correspondencia por regex.\n&#34;;
        }
    }

}
</code></pre><p>Agora se você mandar uma request para <a href=http://nginx.test/Machado8>http://nginx.test/Machado8</a>, você vai ter a seguinte resposta:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test/Machado8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Wed, 26 Feb 2025 01:09:12 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 29</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># correspondencia por prefixo.</span>
</span></span></code></pre></div><p>Dessa vez, a correspondência por prefixo ganhou. Então a lista de correspondências tem a seguinte ordem de prioridade:</p><table><thead><tr><th>Correspondência</th><th>Modificador</th></tr></thead><tbody><tr><td>Exata</td><td><code>=</code></td></tr><tr><td>Prefixo preferencial</td><td><code>^~</code></td></tr><tr><td>REGEX</td><td><code>~</code> ou <code>~*</code></td></tr><tr><td>Prefixo</td><td><code>Nenhum</code></td></tr></tbody></table><h3 id=variáveis-no-nginx>Variáveis no NGINX<a hidden class=anchor aria-hidden=true href=#variáveis-no-nginx>#</a></h3><p>Variáveis no NGINX são semelhantes a variáveis em outras linguagens de programação. A diretiva <code>set</code> pode ser usada para declarar novas variáveis em qualquer lugar no arquivo de configuração:</p><pre tabindex=0><code class=language-conf data-lang=conf>set $&lt;nome_da_variavel&gt; &lt;valor_da_variavel&gt;;

# set nome &#34;Felipe&#34;
# set idade 20
# set esta_trabalhando true
</code></pre><p>Variáveis podem ser de três tipos:</p><ul><li>String</li><li>Inteiro</li><li>Booleano</li></ul><p>Fora as variáveis que você declara, existem variáveis embutidas nos módulos do NGINX. Um <a href=https://nginx.org/en/docs/varindex.html>índice em ordem alfabética dessas variáveis</a> está disponível na documentação oficial.</p><p>Para ver as variáveis em ação, atualize a configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        return 200 &#34;Host - $host\nURI - $uri\nArgs - $args\n&#34;;
    }

}
</code></pre><p>Fazendo uma request para o servidor, você deve receber uma resposta como a seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i <span style=color:#e6db74>&#39;http://nginx.test/teste?parametro=valor&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Wed, 26 Feb 2025 01:19:20 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/plain</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 54</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Host - nginx.test</span>
</span></span><span style=display:flex><span><span style=color:#75715e># URI - /teste</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Args - parametro=valor</span>
</span></span></code></pre></div><p>Como você pode ver, as variáveis <code>$host</code> e <code>$uri</code> tem o valor do endereço base acessado e a URI relativa ao endereço base, respectivamente. A variável <code>$args</code>, como pode ver, contém todos os query params.</p><p>Ao invés de printar a string literal dos query params, você pode acessar os valores individuais usando a variável <code>$arg</code>.</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    server {

        listen 80;
        server_name nginx.test;

        set $nome $arg_nome; # $arg_&lt;query param nome&gt;

        return 200 &#34;Nome - $nome\n&#34;;
    }

}
</code></pre><p>Agora a resposta do servidor vai ser como o seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i <span style=color:#e6db74>&#39;http://nginx.test?nome=felipe&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Nome - felipe
</span></span></code></pre></div><h3 id=redirecionamentos-e-reescritas>Redirecionamentos e Reescritas<a hidden class=anchor aria-hidden=true href=#redirecionamentos-e-reescritas>#</a></h3><p>Um redirecionamento no NGINX é o mesmo de redirecionar em qualquer outra plataforma. Para demonstrar como os redirecionamentos funcionam, atualize sua configuração para ser algo como o seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;

        location = /pagina_index {
                return 307 /index.html;
        }

        location = /pagina_sobre {
                return 307 /sobre.html;
        }
    }
}
</code></pre><p>Agora se você mandar uma request para <a href=http://nginx.test/pagina_sobre>http://nginx.test/pagina_sobre</a>, você vai ser redirecionado para <a href=http://nginx.test/sobre.html>http://nginx.test/sobre.html</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -I http://nginx.test/pagina_sobre
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 307 Temporary Redirect</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Sun, 02 Mar 2025 00:22:15 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/html</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 171</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Location: http://nginx.test/sobre.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span></code></pre></div><p>Como pode ver, o servidor respondeu com um status code de 307 e o <code>location</code> indica a url <a href=http://nginx.test/sobre.html>http://nginx.test/sobre.html</a>. Se você visitar <a href=http://nginx.test/pagina_sobre>http://nginx.test/pagina_sobre</a>, você vai ver que a URL vai automaticamente mudar para <a href=http://nginx.test/sobre.html>http://nginx.test/sobre.html</a>.</p><p>Uma diretiva <code>rewrite</code>, no entanto, funciona um pouco diferente. Ela muda a URI internamente, sem deixar o usuário saber. Para vê-lo em ação, atualize sua configuração como o seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;

        rewrite /pagina_index /index.html;

        rewrite /pagina_sobre /sobre.html;
    }
}
</code></pre><p>Agora se você mandar uma request para <a href=http://nginx.test/pagina_sobre>http://nginx.test/pagina_sobre</a>, você vai ter uma resposta 200 e o código HTML para a página sobre.html na resposta:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test/pagina_sobre
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Sun, 02 Mar 2025 00:41:29 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/html</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 884</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ETag: &#34;67bd1272-374&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Accept-Ranges: bytes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;!DOCTYPE html&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;html lang=&#34;pt-br&#34;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;head&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;meta charset=&#34;UTF-8&#34;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;title&gt;Exemplo site estático&lt;/title&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;link rel=&#34;stylesheet&#34; href=&#34;mini.min.css&#34;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;style&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># .container {</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># max-width: 1024px;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># margin-left: auto;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># margin-right: auto;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># }</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># h1 {</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># text-align: center;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># }</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;/style&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;/head&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;body class=&#34;container&#34;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;header&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># &lt;a class=&#34;button&#34; href=&#34;index.html&#34;&gt;Index&lt;/a&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># &lt;a class=&#34;button&#34; href=&#34;sobre.html&#34;&gt;Sobre&lt;/a&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># &lt;a class=&#34;button&#34; href=&#34;nada&#34;&gt;Nada&lt;/a&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;/header&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;img src=&#34;./nginx.jpg&#34; alt=&#34;Logo do NGINX&#34;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;div class=&#34;card fluid&#34;&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># &lt;h1&gt;esse é o arquivo de &lt;strong&gt;sobre.html&lt;/strong&gt;&lt;/h1&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># &lt;/div&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;/body&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;/html&gt;</span>
</span></span></code></pre></div><p>Agora se você visitar essa URI no browser, você vai ver a página sobre.html enquanto a URI não é alterada</p><p>Fora a parte de como se lida com a mudança de URI, tem outra diferença entre o redirecionamento e a reescrita. Quando uma reescrita acontece, o contexto <code>server</code> é recalculada pelo NGINX. Então uma reescrita é mais pesada do que um redirecionamento.</p><h3 id=como-tentar-por-múltiplos-arquivos>Como tentar por múltiplos arquivos<a hidden class=anchor aria-hidden=true href=#como-tentar-por-múltiplos-arquivos>#</a></h3><p>O conceito final que vou mostrar nessa seção é a diretiva <code>try_files</code>. Ao invés de responder com um único arquivo, a diretiva <code>try_files</code> permite você checar a existência de múltiplos arquivos.</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;

        try_files /nginx.jpg /nao_encontrado;

        location /nao_encontrado {
                return 404 &#34;Infelizmente não encontramos o que você pediu!\n&#34;;
        }
    }
}
</code></pre><p>Como pode ver, uma nova diretiva <code>try_files</code> foi adicionada. Adicionando <code>try_files /nginx.jpg /nao_encontrado;</code> você está instruindo o NGINX para procurar por um arquivo chamado nginx.jpg na raiz sempre que uma request chegar. Se não existir, vá para a URI <code>/not_found</code>.</p><p>O problema em escrever uma diretiva <code>try_files</code> dessa forma é que não importa qual URL você visite, contanto que a request seja recebida pelo servidor e a imagem nginx.jpg for encontrada no disco, NGINX vai retornarná-la.</p><p>E é por isso que <code>try_files</code> é comumente utilizada com a variável <code>$uri</code></p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;

        try_files $uri /nao_encontrado;

        location /nao_encontrado {
                return 404 &#34;Infelizmente não encontramos o que você pediu!\n&#34;;
        }
    }
}
</code></pre><p>Escrevendo <code>try_files $uri /nao_encontrado;</code> você está instruindo o NGINX para tentar pela URI requisitada pelo cliente primeiro. Se ele não encontrar o primeiro, ele vai tentar o próximo.</p><p>Agora se você visitar <a href=http://nginx.test/index.html>http://nginx.test/index.html</a> você deve receber a página index.html normalmente. O mesmo valo para a página sobre.html mas se você requisitar um arquivo que não existe, você via receber a resposta da rota <code>/not_found</code></p><p>Uma coisa que talvez você já tenha percebido é que se você visitar a raiz do servidot <a href=http://nginx.test>http://nginx.test</a> você vai receber a resposta 404.</p><p>Isso acontece porque quando você está requisitando pela raiz do servidor, a variável <code>$uri</code> não corresponde a nenhum arquivo existente então o NGINX serve a URI de fallback. Se você quer consertar esse problema, atualize sua configuração como o seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        root /srv/exemplos-nginx/static-demo;

        try_files $uri $uri/ /nao_encontrado;

        location /nao_encontrado {
                return 404 &#34;Infelizmente não encontramos o que você pediu!\n&#34;;
        }
    }
}
</code></pre><p>Ao escrever <code>try_files $uri $uri/ /nao_encontrado;</code> você está instruindo o NGINX para tentar pela URI requisitada primeiro. Se isso não funcionar então tentar a URI requisitada como um diretório, e quando o NGINX procurar por um diretório ele automaticamente começa a procurar por um arquivo index.html.</p><p>O <code>try_files</code> é o tipo de diretiva que pode ser usada em um número de variações. Nas próximas seções você vai encontrar outras variações mas eu sugiro que você faça alguma pesquisa na internet sobre os diferentes usos da diretiva.</p><h2 id=logs-no-nginx>Logs no NGINX<a hidden class=anchor aria-hidden=true href=#logs-no-nginx>#</a></h2><p>Por padrão, os arquivos de log do NGINX são localizados dentro da pasta <code>/var/log/nginx</code>. Se você listar o conteúdo deste diretório, você via ver algo como o seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ls -lh /var/log/nginx/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx 1 root root 11 Feb  6 00:26 access.log -&gt; /dev/stdout</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lrwxrwxrwx 1 root root 11 Feb  6 00:26 error.log -&gt; /dev/stderr</span>
</span></span></code></pre></div><p>Vamos começar limpando os dois arquivos</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># deleta os arquivos antigos</span>
</span></span><span style=display:flex><span>sudo rm /var/log/nginx/access.log /var/log/nginx/error.log
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># criar os novos arquivos</span>
</span></span><span style=display:flex><span>sudo touch /var/log/nginx/access.log /var/log/nginx/error.log
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># reabrir os arquivos de log</span>
</span></span><span style=display:flex><span>sudo nginx -s reopen
</span></span></code></pre></div><p>Se você não disparar um sinal de <code>reopen</code> pro NGINX, ele vai continuar escrevendo logs para as stream de logs antigas e os novos arquivos vão continuar vazios.</p><p>Agora para fazer uma entrada no access log, mande uma request para o servidor.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -I http://nginx.test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Mon, 03 Mar 2025 21:29:35 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: text/html</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Length: 878</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Last-Modified: Tue, 25 Feb 2025 00:44:34 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ETag: &#34;67bd1272-36e&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Accept-Ranges: bytes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo cat /var/log/nginx/access.log
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 192.168.100.86 - - [03/Mar/2025:21:29:35 +0000] &#34;HEAD / HTTP/1.1&#34; 200 0 &#34;-&#34; &#34;curl/8.12.1&#34;</span>
</span></span></code></pre></div><p>Como pode ver, uma nova entrada foi adicionada no arquivo <code>access.log</code>. Qualquer request para o servidor vai ser logado nesse arquivo por padrão. Mas podemos mudar isso usando a diretiva <code>access_log</code>.</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        location / {
            return 200 &#34;Isso vai ser logado no arquivo padrão.\n&#34;;
        }

        location = /admin {
            access_log /var/logs/nginx/admin.log;

            return 200 &#34;Isso vai ser logado em um arquivo separado.\n&#34;;
        }

        location = /sem_log {
            access_log off;

            return 200 &#34;Isso não vai ser logado.\n&#34;;
        }
    }
}
</code></pre><p>O primeiro <code>access_log</code> dentro do bloco <code>location</code> /admin instrui o NGINX para escrever qualquer access log dessa URI para o arquivo <code>/var/logs/nginx/admin.log</code>. O segundo dentro do <code>location</code> /sem_log desliga o access_log para essa <code>location</code> completamente.</p><p>Valide e recarregue a configuração. Agora se você enviar requests para essas URIs e inspecionar os arquivos de log, eles vão estar de acordo com o que foi configurado.</p><p>O arquivo <code>error.log</code>, por outro lado, armazena os logs de falha. Para fazer uma entrada no <code>error.log</code>, você terá que fazer o NGINX crashar. Para fazê-lo, atualize sua configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        return 200 &#34;...&#34; &#34;...&#34;;
    }

}
</code></pre><p>Como você sabe, a diretiva <code>return</code> só recebe dois parâmetros, mas aqui nós passamos três. Tente recarregar a configuração e você deve ser apresentado com uma mensagem de erro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo nginx -s reload
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># nginx: [emerg] invalid number of arguments in &#34;return&#34; directive in /etc/nginx/nginx.conf:14</span>
</span></span></code></pre></div><p>Cheque o conteúdo do log de erro e a mensagem deve estar presente lá também:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo cat /var/log/nginx/error.log
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2025/03/03 21:49:10 [emerg] 106#106: invalid number of arguments in &#34;return&#34; directive in /etc/nginx/nginx.conf:14</span>
</span></span></code></pre></div><p>Mensagens de erro tem níveis. Uma entrada <code>notice</code> no log de erro é inofensivo, mas um <code>emerg</code> ou entrada de emergência deve ser resolvida logo.</p><p>Existem oito níveis de mensagem de erro:</p><ul><li><code>debug</code> - Informações úteis de debug para determinar onde está o problema</li><li><code>info</code> - Mensagens informativas que não são necessárias de ler, mas são boas de se saber</li><li><code>notice</code> - Algor normal aconteceu e não vale basicamente nada</li><li><code>warn</code> - Algo inesperado aconteceu, mas não deve ser algo preocupante</li><li><code>error</code> - Alguma coisa não foi bem sucedida</li><li><code>crit</code> - Existem problemas críticos no funcionamento do servidor</li><li><code>alert</code> - Alguma ação é necessária</li><li><code>emerg</code> - O sistema está inutilizável e requer atenção imediata</li></ul><p>Por padrão, o NGINX grava todos os níveis de mensagem. Você pode sobrescrever esse comportamento usando a diretiva <code>error_log</code>. Se você quer determinar que o nível mínimo de erro deve ser <code>warn</code>, atualize sua configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {

        listen 80;
        server_name nginx.test;

        error_log /var/log/error.log warn;

        return 200 &#34;...&#34; &#34;...&#34;;
    }

}
</code></pre><p>Para a maioria dos projetos, deixar a configuração de erro como está deve ser o suficiente. A única sugestão é setar o log mínimo de erro para o <code>warn</code>. Dessa forma você não tem de ver entradas desnecessárias no log de erro.</p><p>De toda forma, se quiser aprender mais sobre customizar os logs no NGINX, consulte a <a href=https://docs.nginx.com/nginx/admin-guide/monitoring/logging/>documentação oficial</a></p><h2 id=como-usar-o-nginx-como-uma-proxy-reversa>Como usar o NGINX como uma proxy reversa<a hidden class=anchor aria-hidden=true href=#como-usar-o-nginx-como-uma-proxy-reversa>#</a></h2><p>Quando configurado como uma proxy reversa, o NGINX fica entre o client e o servidor backend. O client manda requests para o NGINX, e então o NGINX passa a request para o backend.</p><p>Uma vez que o servidor backend terminar de processar a request, ele manda de volta para o NGINX. Então, o NGINX retorna a response para o client.</p><p>Durante todo o processo, o client não tem ideia de quem está realmente processando a request. Parece complicado na hora de explicar, mas uma vez que você fizer, verá o quão fácil é fazer isso com o NGINX.</p><p>Vamos ver uma configuração básica e não muito prática de uma proxy reversa:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {

    include /etc/nginx/mime.types;

    server {
        listen 80;
        server_name nginx.test;

        location / {
                proxy_pass &#34;http://nginx.org/&#34;;
        }
    }
}
</code></pre><p>Agora se você visitar <a href=http://nginx.test>http://nginx.test</a>, você vai ser recebido pelo nginx.org original, mesmo a URL estando inalterada.</p><p>Você também deve conseguir navegar pelo site, acessando cada página da documentação.</p><p>Como pode ver, em um nível básico, a diretiva <code>proxy_pass</code> simplesmente passa a request do client para um servidor de terceiros e faz a proxy reversa da resposta pro client.</p><h3 id=node-com-nginx>Node com NGINX<a hidden class=anchor aria-hidden=true href=#node-com-nginx>#</a></h3><p>Agora você sabe como configurar um servidor básico de proxy reverso, você pode servir uma aplicação node usando o NGINX. Eu adicionei uma aplicação demo dentro do repositório que vem com esse artigo.</p><blockquote><p>Estou pressupondo que você tem experiência com Node.js e sabe como iniciar uma aplicação usando o PM2.</p></blockquote><p>Se você já clonou o repositório dentro do <code>/srv/exemplos-nginx</code> então o projeto <code>node-js-demo</code> deve estar disponível no diretório</p><p>Para essa demo funcionar você vai precisar instalar o Node.js no seu servidor. Você pode fazer isso seguindo as instruções da <a href=https://nodejs.org/en/download>documentação oficial</a></p><p>Essa aplicação de demonstração é um servidor HTTP simples que responde com um status 200 e um payload JSON. Você pode iniciar a aplicação simplesmente executando <code>node app.js</code> mas uma maneira melhor de fazer isso é usando <a href=https://pm2.keymetrics.io/>PM2</a>.</p><p>Para quem não sabe, PM2 é um gerenciador de projetos usado amplamente em projetos node em produção. Se quiser saber mais, esse <a href=https://pm2.keymetrics.io/docs/usage/quick-start/>link</a> pode ajudar.</p><p>Instale PM2 globalmente executando <code>sudo npm install -g pm2</code>. Depois da instalação, execute o seguinte comando dentro do diretório `/srv/exemplos-nginx/node-js-demo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>pm2 start app.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># [PM2] Spawning PM2 daemon with pm2_home=/root/.pm2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [PM2] PM2 Successfully daemonized</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [PM2] Starting /srv/exemplos-nginx/node-js-demo/app.js in fork_mode (1 instance)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [PM2] Done.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ┌────┬────────────────────┬──────────┬──────┬───────────┬──────────┬──────────┐</span>
</span></span><span style=display:flex><span><span style=color:#75715e># │ id │ name               │ mode     │ ↺    │ status    │ cpu      │ memory   │</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ├────┼────────────────────┼──────────┼──────┼───────────┼──────────┼──────────┤</span>
</span></span><span style=display:flex><span><span style=color:#75715e># │ 0  │ app                │ fork     │ 0    │ online    │ 0%       │ 37.4mb   │</span>
</span></span><span style=display:flex><span><span style=color:#75715e># └────┴────────────────────┴──────────┴──────┴───────────┴──────────┴──────────┘</span>
</span></span></code></pre></div><p>Você pode parar a aplicação rodando o comando <code>pm2 stop app</code></p><p>A aplicação deve estar rodando agora, mas não deve ser acessível do lado de fora do servidor. Para verificar se a aplicação está rodando, envie uma request para o http://localhost:3000 de dentro do seu servidor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i localhost:3000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: application/json</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Sun, 30 Mar 2025 12:57:28 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Keep-Alive: timeout=5</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Transfer-Encoding: chunked</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># { &#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Você está aprendendo NGINX!&#34; }</span>
</span></span></code></pre></div><p>Se você recebeu uma resposta 200, então o servidor está funcionando normalmente. Para configurar o NGINX como uma proxy reversa, abra seu arquivo de configuração e atualize o conteúdo como o seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {
	server {
	    listen 80;
	    server_name nginx.test;

	    location / {
	        proxy_pass http://localhost:3000;
	    }
	}
}
</code></pre><p>Nada novo para explicar aqui. Você só está passando a requisição recebido para o aplicação Node.js rodando na porta 3000. Agora se você enviar uma request para o servidor do lado de fora você vai receber uma resposta da seguinte forma:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -i http://nginx.test
</span></span><span style=display:flex><span><span style=color:#75715e># HTTP/1.1 200 OK</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Server: nginx/1.27.4</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Date: Sun, 30 Mar 2025 13:35:37 GMT</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Content-Type: application/json</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Transfer-Encoding: chunked</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection: keep-alive</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># { &#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Você está aprendendo NGIN&#34; }</span>
</span></span></code></pre></div><p>Apesar disso funcionar para um servidor básico como esse, você pode ter que adicionar mais algumas diretivas para fazer isso funcionar em um cenário do mundo real dependendo dos requisitos da sua aplicação.</p><p>Por exemplo, se sua aplicação lida com conexões de websocket, então você deve atualizar sua configuração como a seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>events <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>http <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	server <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	    listen 80;
</span></span><span style=display:flex><span>	    server_name nginx.test;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    location / <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	        proxy_pass http://localhost:3000;
</span></span><span style=display:flex><span>			proxy_http_version 1.1;
</span></span><span style=display:flex><span>	        proxy_set_header Upgrade $http_upgrade;
</span></span><span style=display:flex><span>	        proxy_set_header Connection <span style=color:#e6db74>&#39;upgrade&#39;</span>;
</span></span><span style=display:flex><span>	    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>A diretiva <code>proxy_http_version</code> define a versão do HTTP do servidor. Por padrão é 1.0, mas para usar websocket é necessário que seja pelo menos 1.1. A diretiva <code>proxy_set_header</code> é usada por definir um header no servidor. A sintaxe para essa diretiva é algo como:</p><pre tabindex=0><code class=language-conf data-lang=conf>proxy_set_header &lt;nome do header&gt; &lt;valor do header&gt;
</code></pre><p>Escrevendo <code>proxy_set_header Upgrade $http_upgrade;</code> você está instruindo NGINX para passar o valor da variável <code>$http_upgrade</code> como header chamado <code>Upgrade</code>, o mesmo pelo header <code>Connection</code></p><p>Se quiser saber mais sobre proxy de websocket, esse <a href=https://nginx.org/en/docs/http/websocket.html>link</a> da documentação oficial pode ajudar.</p><p>Dependendo dos headers que sua aplicação precisa, você pode ter que definir mais deles. Mas a configuração acima é comumente utilizada para servir aplicações Node.js</p><h2 id=como-usar-o-nginx-como-um-load-balancer>Como usar o NGINX como um load balancer<a hidden class=anchor aria-hidden=true href=#como-usar-o-nginx-como-um-load-balancer>#</a></h2><p>Graças ao design de proxy reversa do NGINX, você pode facilmente configurar ele como um load balancer.</p><p>No diretório <code>/srv/exemplos-nginx/load-balancer-demo</code> você deve encontrar uma demonstração que vamos utilizar nessa parte. Caso não tenha clonado o repositório nessa pasta ainda, agora é um bom momento para fazê-lo.</p><p>Num cenário real, fazer um balanceamento de cargo é necessário em projetos de larga escala distribuídos em múltiplos servidores. Mas para essa simples demonstração, eu criei 3 servidores node simples que respondem como o número do servidor e o status code 200.</p><p>Para essa demo funcionar você vai precisar instalar o Node.js no seu servidor. Você pode fazer isso seguindo as instruções da <a href=https://nodejs.org/en/download>documentação oficial</a></p><p>Além disso, você também vai precisar do <a href=https://pm2.keymetrics.io/>PM2</a> para rodar os servidores dessa demo.</p><p>Se você não fez isso ainda, instale o PM2 com o comando <code>npm install -g pm2</code>. Depois da instalação acabar, execute o seguinte comando para executar os 3 servidores:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>pm2 start /srv/exemplos-nginx/load-balancer-demo/server-1.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pm2 start /srv/exemplos-nginx/load-balancer-demo/server-2.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pm2 start /srv/exemplos-nginx/load-balancer-demo/server-3.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pm2 list
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ┌────┬────────────────────┬──────────┬──────┬───────────┬──────────┬──────────┐</span>
</span></span><span style=display:flex><span><span style=color:#75715e># │ id │ name               │ mode     │ ↺    │ status    │ cpu      │ memory   │</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ├────┼────────────────────┼──────────┼──────┼───────────┼──────────┼──────────┤</span>
</span></span><span style=display:flex><span><span style=color:#75715e># │ 0  │ server-1           │ fork     │ 0    │ online    │ 0%       │ 37.4mb   │</span>
</span></span><span style=display:flex><span><span style=color:#75715e># │ 1  │ server-2           │ fork     │ 0    │ online    │ 0%       │ 37.2mb   │</span>
</span></span><span style=display:flex><span><span style=color:#75715e># │ 2  │ server-3           │ fork     │ 0    │ online    │ 0%       │ 37.1mb   │</span>
</span></span><span style=display:flex><span><span style=color:#75715e># └────┴────────────────────┴──────────┴──────┴───────────┴──────────┴──────────┘</span>
</span></span></code></pre></div><p>Três servidores Node.js devem estar rodando em localhost:3001, localhost:3002, localhost:3003 respectivamente.</p><p>Agora atualize sua configuração como a seguinte:</p><pre tabindex=0><code class=language-conf data-lang=conf>events {

}

http {
    upstream backend_servers {
        server localhost:3001;
        server localhost:3002;
        server localhost:3003;
    }

    server {
        listen 80;
        server_name nginx.test;

        location / {
            proxy_pass http://backend_servers;
        }
    }
}
</code></pre><p>A configuração dentro do contexto de <code>server</code> é o mesmo que já vimos antes. Mas o contexto <code>upstream</code> é novo. Um upstream no NGINX é uma coleção de servidores que pode ser tratado como apenas um backend.</p><p>Então os três servidores que inciamos usando PM2 pode ser colocado dentro de apenas um upstream e você deixar que o NGINX faça o balanceamento de carga entre eles.</p><p>Para testar a configuração, você vai ter que mandar mais de uma request para o servidor. Você pode automatizar o processo usando um loop <code>while</code> em bash:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#66d9ef>while</span> sleep 0.5; <span style=color:#66d9ef>do</span> curl http://nginx.test; <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 2.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 3.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 1.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 3.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 1.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 2.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 2.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 3.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># resposta do servidor - 1.</span>
</span></span></code></pre></div><p>Você pode cancelar o loop pressionando <code>Ctrl + C</code> no seu teclado. Como pode ver das respostas do servidor, o NGINX faz o balanceamento de carga automaticamente.</p><p>Claro, dependendo da escala do projeto, balancear a carga pode ser muito mais complicado que isso. Mas o objetivo desse artigo é te dar uma base. Você pode parar os servidores node executando <code>pm2 stop all</code></p><h2 id=como-configurar-processos-worker-e-conexões-worker>Como configurar processos worker e conexões worker<a hidden class=anchor aria-hidden=true href=#como-configurar-processos-worker-e-conexões-worker>#</a></h2><p>Como mencionei em seções anteriores, o NGINX pode iniciar múltiplos processos worker, capazes de lidar com milhares de requests cada um.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo systemctl status nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ● nginx.service - A high performance web server and a reverse proxy server</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Active: active (running) since Sun 2025-03-23 08:33:11 UTC; 5h 45min ago</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#        Docs: man:nginx(8)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    Main PID: 3904 (nginx)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       Tasks: 2 (limit: 1136)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Memory: 3.2M</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      CGroup: /system.slice/nginx.service</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              ├─ 3904 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              └─16443 nginx: worker process</span>
</span></span></code></pre></div><p>Como pode ver, agora tem apenas um processo worker do NGINX no sistema. Entretanto, esse número pode ser alterado fazendo uma pequena mudança no arquivo de configuração.</p><pre tabindex=0><code class=language-conf data-lang=conf>worker_processes 2;

events {

}

http {

    server {
        listen 80;
        server_name nginx.test;

        return 200 &#34;Hello World :)&#34;;
    }
}
</code></pre><p>A diretiva <code>worker_process</code> escrita no contexto <code>main</code> é responsável por definir o número de processos worker para iniciar. Agora cheque o serviço do NGINX novamente e você deve ver dois processos worker:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl status nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ● nginx.service - A high performance web server and a reverse proxy server</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Active: active (running) since Sun 2025-03-23 08:33:11 UTC; 5h 54min ago</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#        Docs: man:nginx(8)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     Process: 22610 ExecReload=/usr/sbin/nginx -g daemon on; master_process on; -s reload (code=exited, status=0/SUCCESS)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    Main PID: 3904 (nginx)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       Tasks: 3 (limit: 1136)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Memory: 3.7M</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      CGroup: /system.slice/nginx.service</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              ├─ 3904 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              ├─22611 nginx: worker process</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              └─22612 nginx: worker process</span>
</span></span></code></pre></div><p>Definindo o número de processos worker é fácil, mas determinar o número ideal de processos worker dá um pouco mais de trabalho.</p><p>Os processos worker tem natureza assíncrona. Isso significa que eles vão processar as requests que chegam o mais rápido que o hardware pode.</p><p>Agora considere que seu servidor rode em um processador com um core de processamento. Se você definir o número de processos worker para 1, aquele único processo vai utilizar 100% da capacidade do processador. Mas se você definir como 2, os 2 processos vão ser capazes de utilizar 50% do processador cada um. Então aumentar o número de processos worker não significa uma performance melhor.</p><p>Uma boa regra a se seguir é determinar o número de processos worker como o número de cores do seu processador.</p><p>Determinar o número de cores do processador no seu servidor é muito fácil no Linux.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nproc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1</span>
</span></span></code></pre></div><p>Eu estou em uma máquina virtual de apenas um core, então o <code>nproc</code> identifica que tem apenas um core. Agora que você sabe o número de cores, tudo que resta fazer é definir o número na configuração.</p><p>Até aí tudo bem, mas toda vez que você fizer upgrade no processador do servidor, vai ter de alterar a configuração manualmente.</p><p>O NGINX provê uma forma melhor de lidar com esse problema. Você pode simplesmente definir o número de processos como <code>auto</code> e o NGINX vai definir o número de processos baseado no número de cores do processador automaticamente.</p><pre tabindex=0><code class=language-conf data-lang=conf>worker_processes auto;

events {

}

http {

    server {
        listen 80;
        server_name nginx.test;

        return 200 &#34;Hello World :)&#34;;
    }
}
</code></pre><p>Inspecione o processo do NGINX novamente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl status nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ● nginx.service - A high performance web server and a reverse proxy server</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Active: active (running) since Sun 2025-03-23 08:33:11 UTC; 6h ago</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#        Docs: man:nginx(8)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     Process: 22610 ExecReload=/usr/sbin/nginx -g daemon on; master_process on; -s reload (code=exited, status=0/SUCCESS)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    Main PID: 3904 (nginx)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       Tasks: 2 (limit: 1136)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Memory: 3.2M</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      CGroup: /system.slice/nginx.service</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              ├─ 3904 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              └─23659 nginx: worker process</span>
</span></span></code></pre></div><p>O número de processos worker está de volta em 1, isso porque esse é o mais otimizado nesse servidor.</p><p>Além dos processos worker também existem as conexões worker, indicando o número máximo de conexões que um único worker pode processar.</p><p>Assim como o número de processos worker, esse número também está relacionado ao processador e ao número de arquivos que seu sistema operacional pode abrir por core.</p><p>Encontrar esse número é bem fácil no Linux:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ulimit -n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1024</span>
</span></span></code></pre></div><p>Agora que temos esse número, tudo que nos resta é definir isso na configuração:</p><pre tabindex=0><code class=language-conf data-lang=conf>worker_processes auto;

events {
	worker_connections 1024;
}

http {

    server {
        listen 80;
        server_name nginx.test;

        return 200 &#34;Hello World :)&#34;;
    }
}
</code></pre><p>A diretiva <code>worker_connections</code> é responsável por definir o número de conexões worker em uma configuração. Essa também é a primeira vez que você está alterando o contexto <code>events</code>.</p><p>Em uma seção anterior, eu mencionei que esse contexto é utilizado para definir valores usados pelo NGINX é um nível geral. A configuração de conexões worker é um exemplo desse tipo de configuração.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.felpo.dev/>Felpo Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>