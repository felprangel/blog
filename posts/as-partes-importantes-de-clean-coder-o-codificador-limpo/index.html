<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>As partes importantes de Clean Coder (O Codificador Limpo) | Felpo Blog</title>
<meta name=keywords content><meta name=description content="Para ser sincero, estou escrevendo este post mais para minhas consultas futuras do que por qualquer outro motivo, mas sei que pode ser útil para outras pessoas. Dito isso, tentei explicar com minhas palavras os pontos mais importantes do livro em cada capítulo.
Lembre-se: nada aqui é regra absoluta. Tudo pode e deve ser questionado. Agora, sem mais delongas, vamos aos capítulos!
Profissionalismo
Profissionalismo = Responsabilidade
Não cause danos ao funcionamento

[&mldr;] Software é muito complexo para ser criado sem bugs. Mas infelizmente, isso não o exime de sua responsabilidade. O corpo humano é muito complexo para ser entendido plenamente, mas os médicos ainda fazem um juramento para não danificá-lo. Se eles não se eximem da responsabilidade, por que nós deveríamos?"><meta name=author content><link rel=canonical href=https://blog.felpo.dev/posts/as-partes-importantes-de-clean-coder-o-codificador-limpo/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.felpo.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.felpo.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.felpo.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.felpo.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.felpo.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.felpo.dev/posts/as-partes-importantes-de-clean-coder-o-codificador-limpo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.felpo.dev/posts/as-partes-importantes-de-clean-coder-o-codificador-limpo/"><meta property="og:site_name" content="Felpo Blog"><meta property="og:title" content="As partes importantes de Clean Coder (O Codificador Limpo)"><meta property="og:description" content="Para ser sincero, estou escrevendo este post mais para minhas consultas futuras do que por qualquer outro motivo, mas sei que pode ser útil para outras pessoas. Dito isso, tentei explicar com minhas palavras os pontos mais importantes do livro em cada capítulo.
Lembre-se: nada aqui é regra absoluta. Tudo pode e deve ser questionado. Agora, sem mais delongas, vamos aos capítulos!
Profissionalismo Profissionalismo = Responsabilidade Não cause danos ao funcionamento […] Software é muito complexo para ser criado sem bugs. Mas infelizmente, isso não o exime de sua responsabilidade. O corpo humano é muito complexo para ser entendido plenamente, mas os médicos ainda fazem um juramento para não danificá-lo. Se eles não se eximem da responsabilidade, por que nós deveríamos?"><meta property="og:locale" content="pt-br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="As partes importantes de Clean Coder (O Codificador Limpo)"><meta name=twitter:description content="Para ser sincero, estou escrevendo este post mais para minhas consultas futuras do que por qualquer outro motivo, mas sei que pode ser útil para outras pessoas. Dito isso, tentei explicar com minhas palavras os pontos mais importantes do livro em cada capítulo.
Lembre-se: nada aqui é regra absoluta. Tudo pode e deve ser questionado. Agora, sem mais delongas, vamos aos capítulos!
Profissionalismo
Profissionalismo = Responsabilidade
Não cause danos ao funcionamento

[&mldr;] Software é muito complexo para ser criado sem bugs. Mas infelizmente, isso não o exime de sua responsabilidade. O corpo humano é muito complexo para ser entendido plenamente, mas os médicos ainda fazem um juramento para não danificá-lo. Se eles não se eximem da responsabilidade, por que nós deveríamos?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.felpo.dev/posts/"},{"@type":"ListItem","position":2,"name":"As partes importantes de Clean Coder (O Codificador Limpo)","item":"https://blog.felpo.dev/posts/as-partes-importantes-de-clean-coder-o-codificador-limpo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"As partes importantes de Clean Coder (O Codificador Limpo)","name":"As partes importantes de Clean Coder (O Codificador Limpo)","description":"Para ser sincero, estou escrevendo este post mais para minhas consultas futuras do que por qualquer outro motivo, mas sei que pode ser útil para outras pessoas. Dito isso, tentei explicar com minhas palavras os pontos mais importantes do livro em cada capítulo.\nLembre-se: nada aqui é regra absoluta. Tudo pode e deve ser questionado. Agora, sem mais delongas, vamos aos capítulos!\nProfissionalismo Profissionalismo = Responsabilidade Não cause danos ao funcionamento [\u0026hellip;] Software é muito complexo para ser criado sem bugs. Mas infelizmente, isso não o exime de sua responsabilidade. O corpo humano é muito complexo para ser entendido plenamente, mas os médicos ainda fazem um juramento para não danificá-lo. Se eles não se eximem da responsabilidade, por que nós deveríamos?\n","keywords":[],"articleBody":"Para ser sincero, estou escrevendo este post mais para minhas consultas futuras do que por qualquer outro motivo, mas sei que pode ser útil para outras pessoas. Dito isso, tentei explicar com minhas palavras os pontos mais importantes do livro em cada capítulo.\nLembre-se: nada aqui é regra absoluta. Tudo pode e deve ser questionado. Agora, sem mais delongas, vamos aos capítulos!\nProfissionalismo Profissionalismo = Responsabilidade Não cause danos ao funcionamento […] Software é muito complexo para ser criado sem bugs. Mas infelizmente, isso não o exime de sua responsabilidade. O corpo humano é muito complexo para ser entendido plenamente, mas os médicos ainda fazem um juramento para não danificá-lo. Se eles não se eximem da responsabilidade, por que nós deveríamos?\nSe você faz um estrago no sistema, não pode simplesmente dar de ombros e dizer: “Ah, tecnologia é assim mesmo”. Responsabilidade é chave.\nO QA não deve encontrar nada Se você envia um código para QA esperando que eles encontrem bugs, parabéns, você está sendo preguiçoso e anti-profissional.\nSempre que um QA (ou pior, um usuário) encontra um bug, você deve ficar surpreso, desapontado e disposto a evitar que isso aconteça novamente. A ideia é que QA seja a última linha de defesa, não a primeira.\nTodo código deve ser testado Você precisa ter certeza que o código funciona, e como você sabe isso? Testando ele!\nEstou sugerindo 100% de cobertura de testes? Não estou sugerindo isso. Estou exigindo. Toda linha de código que você escreve precisa ser testada. Ponto final.\nSe não está testado, está quebrado. Simples assim.\nNão cause danos a estrutura Todo código deve ser fácil de ser alterado e dar manutenção. Se a facilidade da manutenção for sacrificada em troca de rapidez no curto prazo, vai ser criado um lamaçal no código, que atrasa todo mundo que entra nele.\nA única maneira de provar que o software é fácil de alterar é alterando ele.\nCada vez que olha para um módulo você faz pequenas e leves mudanças para melhorar a estrutura. Sempre que ler o código, ajuste a estrutura. […] Faça algumas ações aleatórias sutis em um código, sempre que o ver\nA polêmica das 60 horas semanais Robert diz que um programador profissional deve se dedicar 60 horas semanais: 40 para o empregador e 20 para si mesmo. E se você não pode se comprometer com isso? Bom, segundo ele, você não é um profissional.\nConcordo que estudar 20 horas semanais pode te tornar um profissional melhor, mas achar que quem não consegue fazer isso não é profissional é absurdo. Pessoas têm famílias, deslocamentos longos, vida fora do trabalho. Não é tão simples assim.\nConhecer o seu campo Se você quer ser um profissional de verdade, precisa conhecer seu território. Isso inclui design patterns, princípios como SOLID, metodologias como Agile e Scrum, disciplinas como TDD e orientação a objetos, além de artefatos como diagramas UML. Sim, parece muita coisa, mas acredite: entender essas bases vai te poupar muitas dores de cabeça no futuro.\nComo diz o ditado: “Aquele que não conhece o passado está fadado a repeti-lo”. E, no mundo da programação, isso significa reinventar a roda quadrada.\nAprender sobre a área e os princípios de código é essencial. Afinal, esses conhecimentos atemporais vêm sendo refinados desde os anos 70, e se ainda estão por aí, é porque fazem sentido. Então, antes de sair digitando como um maníaco, vale a pena dar uma olhada no que os mestres do passado já descobriram.\nDizendo não Aprender a dizer “não” pode salvar sua sanidade. Como dizia um ex-chefe meu:\n“É melhor amarelar agora do que envermelhar depois.”\nSe seu gerente pergunta se a tela de login fica pronta até amanhã e você sabe que é impossível, diga não. Não existe “eu vou tentar”. Ou você sabe que consegue ou sabe que não consegue.\nDizendo sim Comprometimento significa:\nVocê diz que vai fazer. Você é honesto. Você faz. Nada de “eu possivelmente termino na terça”. Se você se compromete, você vai terminar na terça.\nCaso ocorra um imprevisto, avise cedo. Ninguém gosta de surpresas de última hora.\nCodificando Se você está cansado ou distraído, não codifique. Sério, só vai piorar as coisas.\nMuitas soluções surgem no banho ou no caminho de volta pra casa.\nE lembre-se: fazer horas extras para cumprir prazos pode ser contraproducente. Código ruim escrito às 2 da manhã vai precisar ser refeito de qualquer forma.\nO livro também alerta sobre a “falsa entrega”—aquele truque de marcar algo como concluído sem realmente terminar, apenas para cumprir o prazo. Spoiler: o tempo para arrumar isso depois nunca aparece, e o código fica para sempre incompleto.\nOutro ponto crucial: ajudar e ser ajudado. Quando alguém pedir sua ajuda, dê atenção. Quando precisar de ajuda, peça. Não faz sentido passar o dia inteiro travado em um problema quando alguém poderia resolver em minutos.\nTest Driven Development (TDD) As três leis do TDD Não escreva código de produção sem antes ter um teste que falha. Não escreva mais de um teste do que o necessário. Não escreva mais código do que o necessário para passar no teste. Coragem Por que você não corrige o código ruim quando o vê? Sua primeira reação ao ver uma função bagunçada é “Isso está uma zona, precisa ser limpo”. Sua segunda reação é “Não vou colocar a mão nisso aqui!”. Por quê? Porque sabe que se tocar corre o risco de quebrar, e se quebrar, a responsabilidade passa a ser sua.\nNovamente, o livro ressalta a importância dos testes automatizados e como eles fazem maravilhas pelo seu código. Afinal, não há nada melhor do que mexer no código, rodar os testes e ter a certeza de que nada quebrou—desde que os testes sejam bem escritos, claro! Como bem coloca o livro, testes automatizados transformam seu código em argila, pronta para ser moldada em estruturas simples e elegantes, sem medo de desmoronar.\nAlém disso, o TDD traz outras vantagens, como documentação e design. Um bom teste automatizado serve como uma documentação viva: ele mostra exatamente como cada classe e função devem ser usadas, sendo muitas vezes mais útil do que longos documentos escritos que ninguém lê.\nJá no quesito design, o TDD “obriga” você a escrever um código fácil de testar e, como efeito colateral positivo, esse código se torna mais legível, compreensível e fácil de manter. Escrever o teste antes do código é uma abordagem ofensiva—o teste molda o código. Escrever o teste depois é defensivo—você protege o código com testes. Ambos os estilos têm seus méritos, e saber quando usar cada um é o que separa um profissional experiente de um programador teimoso.\nPor fim, vale lembrar que TDD não é uma religião nem uma fórmula mágica. Existem situações em que ele pode mais atrapalhar do que ajudar, e um desenvolvedor profissional sabe reconhecer quando é hora de abrir mão da ferramenta em prol da produtividade.\nEstratégias de Teste Pulando alguns capítulos menos relevantes, aqui o livro fala sobre a famosa Pirâmide de Testes:\n100% do código deve ser coberto por testes de unidade 50% do código deve ser coberto por testes de componentes 25% do código deve ser coberto por testes de integração 10% do código deve ser coberto por testes de sistema 5% do código deve ser coberto por testes exploratórios manuais Agora, vamos entender o que isso significa na prática.\nTestes de Unidade Testes de unidade são os mais básicos e devem cobrir 100% do código. Eles testam pequenas partes isoladas do sistema, como funções e métodos, garantindo que cada peça individual funciona como esperado.\nTestes de Componentes Na minha interpretação, testes de componentes verificam pequenos conjuntos do sistema funcionando juntos. Um teste de unidade pode validar uma função isolada de um repository, enquanto um teste de componente verificaria a integração entre o controller, a model e o repository. Esses testes focam no “caminho feliz”, garantindo que tudo funcione quando não há falhas. Já os cenários problemáticos devem ser cobertos pelos testes de unidade.\nTestes de Integração Os testes de integração aumentam a escala, verificando se vários componentes conseguem trabalhar juntos. Eles são coreografados e não testam a lógica de negócio, mas sim se os diferentes módulos do sistema conseguem se comunicar corretamente. Um exemplo prático seria testar se um controller consegue chamar corretamente um repository, interagir com os models e ainda enviar um e-mail via uma fila de mensagens.\nTestes de Sistema Segundo o livro, esses são os testes end-to-end (E2E), que validam o funcionamento do sistema como um todo. Eles são mais demorados e custosos, pois envolvem interações reais entre os diversos serviços, bancos de dados e APIs externas.\nTestes Exploratórios Manuais Aqui entra a parte “humana” da pirâmide. Testadores (ou desenvolvedores destemidos) exploram o sistema buscando falhas, testando edge cases e tentando encontrar exceções que possam ter passado despercebidas pelos testes automatizados. Afinal, sempre existe aquele cenário bizarro que só um usuário real conseguiria descobrir.\nGerenciamento de Tempo Discussões \u0026 Discordâncias “Qualquer discussão que não puder ser resolvida em cinco minutos não pode ser resolvida pela discussão.”\nSe uma discussão se arrasta por mais de cinco minutos, é um sinal claro de que não existem evidências concretas sustentando nenhum dos lados. Nesse caso, o debate deixou de ser técnico e virou algo quase “religioso”, baseado apenas em opiniões e crenças.\nSem dados, discussões longas raramente levam a um consenso. O que fazer, então? Simples: pare de argumentar e vá atrás de mais informações. Teste, simule, faça experimentos! Em alguns casos, quando os dois lados parecem igualmente viáveis, talvez seja mais produtivo jogar uma moeda do que continuar debatendo eternamente.\nMas atenção! Se você aceitou uma decisão, entre no barco de verdade. Nada de “concordar” só para encerrar a conversa e depois ficar no modo passivo-agressivo, esperando algo dar errado para soltar um “eu já sabia que isso não ia dar certo”. Se você concordou, os acertos são seus, e os erros também.\nAtoleiros, Lamaçais e Pântanos Sabe o que é pior do que um beco sem saída? Um lamaçal. Pelo menos no beco sem saída você logo percebe que precisa dar meia-volta. No lamaçal, você vê a luz no fim do túnel e acredita que seguir em frente será mais rápido do que voltar—mas, surpresa! Não é.\nEsse tipo de armadilha começa quando você percebe que tomou uma decisão errada (seja de design, estrutura, arquitetura…) e, ao invés de refazer o caminho, escolhe seguir em frente na esperança de que “vai dar tudo certo”. Spoiler: não vai.\nO pensamento que prende as pessoas no lamaçal é o clássico “Já investi muito tempo nisso, então é melhor continuar do que refazer do zero.” Mas essa é uma ilusão perigosa. O momento certo para parar e mudar de rumo é exatamente quando você percebe que tomou a decisão errada. Insistir no erro só te afunda mais.\nPior ainda, continuar seguindo em frente não é só mentir para si mesmo—é enganar sua equipe, sua empresa e seus clientes. Você pode até dizer “Vai ficar tudo bem!”, mas, no fundo, sabe que está acelerando em direção ao desastre.\nO segredo para evitar lamaçais? Saber a hora de dizer: “Chega, vamos voltar e fazer direito.”\nEstimativa Empresas tratam estimativas como comprometimentos. Desenvolvedores as tratam como palpites.\nUma estimativa é uma distribuição, não um número mágico. Para melhorar suas previsões, o método PERT sugere calcular três estimativas:\nOtimista (O): Se tudo der certo. Nominal (N): A estimativa mais provável. Pessimista (P): Se tudo der errado. Fórmula da previsão:\n$\\frac{O + 4N + P}{6}$ O resultado vai ser a duração da tarefa. Tendo as seguintes estimativas: O: 1, N: 3, P: 12. Teríamos (1 + 12 + 12) / 6 ou em trono de 4,2 dias.\nPara sabermos a divergência padrão, podemos usar o seguinte cálculo:\n$\\frac{P - O}{6}$ Quando o resultado da divergência é grande, a incerteza também é. No exemplo de antes, a divergência é de (12 -1)/6 ou por volta de 1,8 dias\nPressão Não sucumba à tentação de “codar sujo” para ser rápido. Rápido e sujo são paradoxos.\n“Você descobre no que realmente acredita quando a pressão bate. Se você abandona TDD ou código limpo na crise, nunca acreditou neles de verdade.”\nSe você acredita que boas práticas funcionam, siga-as especialmente quando as coisas apertam.\nE assim encerramos. Espero que esse resumo seja útil para você (e para o eu do futuro que vai reler isso).\n","wordCount":"2058","inLanguage":"en","datePublished":"2025-03-01T00:00:00Z","dateModified":"2025-03-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.felpo.dev/posts/as-partes-importantes-de-clean-coder-o-codificador-limpo/"},"publisher":{"@type":"Organization","name":"Felpo Blog","logo":{"@type":"ImageObject","url":"https://blog.felpo.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.felpo.dev/ accesskey=h title="Felpo Blog (Alt + H)">Felpo Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">As partes importantes de Clean Coder (O Codificador Limpo)</h1><div class=post-meta><span title='2025-03-01 00:00:00 +0000 UTC'>March 1, 2025</span></div></header><div class=post-content><p>Para ser sincero, estou escrevendo este post mais para minhas consultas futuras do que por qualquer outro motivo, mas sei que pode ser útil para outras pessoas. Dito isso, tentei explicar com minhas palavras os pontos mais importantes do livro em cada capítulo.</p><p>Lembre-se: nada aqui é regra absoluta. Tudo pode e deve ser questionado. Agora, sem mais delongas, vamos aos capítulos!</p><h2 id=profissionalismo>Profissionalismo<a hidden class=anchor aria-hidden=true href=#profissionalismo>#</a></h2><h3 id=profissionalismo--responsabilidade>Profissionalismo = Responsabilidade<a hidden class=anchor aria-hidden=true href=#profissionalismo--responsabilidade>#</a></h3><h4 id=não-cause-danos-ao-funcionamento>Não cause danos ao funcionamento<a hidden class=anchor aria-hidden=true href=#não-cause-danos-ao-funcionamento>#</a></h4><blockquote><p>[&mldr;] Software é muito complexo para ser criado sem bugs. Mas infelizmente, isso não o exime de sua responsabilidade. O corpo humano é muito complexo para ser entendido plenamente, mas os médicos ainda fazem um juramento para não danificá-lo. Se eles não se eximem da responsabilidade, por que nós deveríamos?</p></blockquote><p>Se você faz um estrago no sistema, não pode simplesmente dar de ombros e dizer: &ldquo;Ah, tecnologia é assim mesmo&rdquo;. Responsabilidade é chave.</p><h4 id=o-qa-não-deve-encontrar-nada>O QA não deve encontrar nada<a hidden class=anchor aria-hidden=true href=#o-qa-não-deve-encontrar-nada>#</a></h4><p>Se você envia um código para QA esperando que eles encontrem bugs, parabéns, você está sendo <em>preguiçoso</em> e <em>anti-profissional</em>.</p><p>Sempre que um QA (ou pior, um usuário) encontra um bug, você deve ficar surpreso, desapontado e disposto a evitar que isso aconteça novamente. A ideia é que QA seja a última linha de defesa, não a primeira.</p><h3 id=todo-código-deve-ser-testado>Todo código deve ser testado<a hidden class=anchor aria-hidden=true href=#todo-código-deve-ser-testado>#</a></h3><p>Você precisa ter certeza que o código funciona, e como você sabe isso? Testando ele!</p><blockquote><p>Estou sugerindo 100% de cobertura de testes? Não estou <em>sugerindo</em> isso. Estou <em>exigindo</em>. Toda linha de código que você escreve precisa ser testada. Ponto final.</p></blockquote><p>Se não está testado, está quebrado. Simples assim.</p><h3 id=não-cause-danos-a-estrutura>Não cause danos a estrutura<a hidden class=anchor aria-hidden=true href=#não-cause-danos-a-estrutura>#</a></h3><p>Todo código deve ser fácil de ser alterado e dar manutenção. Se a facilidade da manutenção for sacrificada em troca de rapidez no curto prazo, vai ser criado um lamaçal no código, que atrasa todo mundo que entra nele.</p><p>A única maneira de provar que o software é fácil de alterar é alterando ele.</p><blockquote><p>Cada vez que olha para um módulo você faz pequenas e leves mudanças para melhorar a estrutura. Sempre que ler o código, ajuste a estrutura. [&mldr;] Faça algumas ações aleatórias sutis em um código, sempre que o ver</p></blockquote><h4 id=a-polêmica-das-60-horas-semanais>A polêmica das 60 horas semanais<a hidden class=anchor aria-hidden=true href=#a-polêmica-das-60-horas-semanais>#</a></h4><p>Robert diz que um programador profissional deve se dedicar 60 horas semanais: 40 para o empregador e 20 para si mesmo. E se você não pode se comprometer com isso? Bom, segundo ele, <em>você não é um profissional</em>.</p><p>Concordo que estudar 20 horas semanais pode te tornar um profissional melhor, mas achar que quem não consegue fazer isso não é profissional é absurdo. Pessoas têm famílias, deslocamentos longos, vida fora do trabalho. Não é tão simples assim.</p><h3 id=conhecer-o-seu-campo>Conhecer o seu campo<a hidden class=anchor aria-hidden=true href=#conhecer-o-seu-campo>#</a></h3><p>Se você quer ser um profissional de verdade, precisa conhecer seu território. Isso inclui design patterns, princípios como SOLID, metodologias como Agile e Scrum, disciplinas como TDD e orientação a objetos, além de artefatos como diagramas UML. Sim, parece muita coisa, mas acredite: entender essas bases vai te poupar muitas dores de cabeça no futuro.</p><p>Como diz o ditado: <em>&ldquo;Aquele que não conhece o passado está fadado a repeti-lo&rdquo;</em>. E, no mundo da programação, isso significa reinventar a roda quadrada.</p><p>Aprender sobre a área e os princípios de código é essencial. Afinal, esses conhecimentos atemporais vêm sendo refinados desde os anos 70, e se ainda estão por aí, é porque fazem sentido. Então, antes de sair digitando como um maníaco, vale a pena dar uma olhada no que os mestres do passado já descobriram.</p><hr><h2 id=dizendo-não>Dizendo não<a hidden class=anchor aria-hidden=true href=#dizendo-não>#</a></h2><p>Aprender a dizer &ldquo;não&rdquo; pode salvar sua sanidade. Como dizia um ex-chefe meu:</p><blockquote><p>&ldquo;É melhor amarelar agora do que envermelhar depois.&rdquo;</p></blockquote><p>Se seu gerente pergunta se a tela de login fica pronta até amanhã e você sabe que é impossível, diga <em>não</em>. Não existe &ldquo;eu vou tentar&rdquo;. Ou você sabe que consegue ou sabe que não consegue.</p><hr><h2 id=dizendo-sim>Dizendo sim<a hidden class=anchor aria-hidden=true href=#dizendo-sim>#</a></h2><p>Comprometimento significa:</p><ol><li>Você diz que vai fazer.</li><li>Você é honesto.</li><li>Você faz.</li></ol><p>Nada de &ldquo;eu <em>possivelmente</em> termino na terça&rdquo;. Se você se compromete, você <strong>vai</strong> terminar na terça.</p><p>Caso ocorra um imprevisto, avise cedo. Ninguém gosta de surpresas de última hora.</p><hr><h2 id=codificando>Codificando<a hidden class=anchor aria-hidden=true href=#codificando>#</a></h2><p>Se você está cansado ou distraído, não codifique. Sério, só vai piorar as coisas.</p><p>Muitas soluções surgem no banho ou no caminho de volta pra casa.</p><p>E lembre-se: fazer horas extras para cumprir prazos pode ser contraproducente. Código ruim escrito às 2 da manhã vai precisar ser refeito de qualquer forma.</p><p>O livro também alerta sobre a &ldquo;falsa entrega&rdquo;—aquele truque de marcar algo como concluído sem realmente terminar, apenas para cumprir o prazo. Spoiler: o tempo para arrumar isso depois <em>nunca</em> aparece, e o código fica para sempre incompleto.</p><p>Outro ponto crucial: ajudar e ser ajudado. Quando alguém pedir sua ajuda, dê atenção. Quando precisar de ajuda, peça. Não faz sentido passar o dia inteiro travado em um problema quando alguém poderia resolver em minutos.</p><hr><h2 id=test-driven-development-tdd>Test Driven Development (TDD)<a hidden class=anchor aria-hidden=true href=#test-driven-development-tdd>#</a></h2><h3 id=as-três-leis-do-tdd>As três leis do TDD<a hidden class=anchor aria-hidden=true href=#as-três-leis-do-tdd>#</a></h3><ol><li>Não escreva código de produção sem antes ter um teste que falha.</li><li>Não escreva mais de um teste do que o necessário.</li><li>Não escreva mais código do que o necessário para passar no teste.</li></ol><h3 id=coragem>Coragem<a hidden class=anchor aria-hidden=true href=#coragem>#</a></h3><blockquote><p>Por que você não corrige o código ruim quando o vê? Sua primeira reação ao ver uma função bagunçada é &ldquo;Isso está uma zona, precisa ser limpo&rdquo;. Sua segunda reação é &ldquo;Não vou colocar a mão nisso aqui!&rdquo;. Por quê? Porque sabe que se tocar corre o risco de quebrar, e se quebrar, a responsabilidade passa a ser sua.</p></blockquote><p>Novamente, o livro ressalta a importância dos testes automatizados e como eles fazem maravilhas pelo seu código. Afinal, não há nada melhor do que mexer no código, rodar os testes e ter a certeza de que nada quebrou—desde que os testes sejam bem escritos, claro! Como bem coloca o livro, testes automatizados transformam seu código em argila, pronta para ser moldada em estruturas simples e elegantes, sem medo de desmoronar.</p><p>Além disso, o TDD traz outras vantagens, como documentação e design. Um bom teste automatizado serve como uma documentação viva: ele mostra exatamente como cada classe e função devem ser usadas, sendo muitas vezes mais útil do que longos documentos escritos que ninguém lê.</p><p>Já no quesito design, o TDD &ldquo;obriga&rdquo; você a escrever um código fácil de testar e, como efeito colateral positivo, esse código se torna mais legível, compreensível e fácil de manter. Escrever o teste antes do código é uma abordagem ofensiva—o teste molda o código. Escrever o teste depois é defensivo—você protege o código com testes. Ambos os estilos têm seus méritos, e saber quando usar cada um é o que separa um profissional experiente de um programador teimoso.</p><p>Por fim, vale lembrar que TDD não é uma religião nem uma fórmula mágica. Existem situações em que ele pode mais atrapalhar do que ajudar, e um desenvolvedor profissional sabe reconhecer quando é hora de abrir mão da ferramenta em prol da produtividade.</p><hr><h2 id=estratégias-de-teste>Estratégias de Teste<a hidden class=anchor aria-hidden=true href=#estratégias-de-teste>#</a></h2><p>Pulando alguns capítulos menos relevantes, aqui o livro fala sobre a famosa Pirâmide de Testes:</p><ul><li><strong>100%</strong> do código deve ser coberto por <strong>testes de unidade</strong></li><li><strong>50%</strong> do código deve ser coberto por <strong>testes de componentes</strong></li><li><strong>25%</strong> do código deve ser coberto por <strong>testes de integração</strong></li><li><strong>10%</strong> do código deve ser coberto por <strong>testes de sistema</strong></li><li><strong>5%</strong> do código deve ser coberto por <strong>testes exploratórios manuais</strong></li></ul><p>Agora, vamos entender o que isso significa na prática.</p><h3 id=testes-de-unidade>Testes de Unidade<a hidden class=anchor aria-hidden=true href=#testes-de-unidade>#</a></h3><p>Testes de unidade são os mais básicos e devem cobrir 100% do código. Eles testam pequenas partes isoladas do sistema, como funções e métodos, garantindo que cada peça individual funciona como esperado.</p><h3 id=testes-de-componentes>Testes de Componentes<a hidden class=anchor aria-hidden=true href=#testes-de-componentes>#</a></h3><p>Na minha interpretação, testes de componentes verificam pequenos conjuntos do sistema funcionando juntos. Um teste de unidade pode validar uma função isolada de um <em>repository</em>, enquanto um teste de componente verificaria a integração entre o <em>controller</em>, a <em>model</em> e o <em>repository</em>. Esses testes focam no &ldquo;caminho feliz&rdquo;, garantindo que tudo funcione quando não há falhas. Já os cenários problemáticos devem ser cobertos pelos testes de unidade.</p><h3 id=testes-de-integração>Testes de Integração<a hidden class=anchor aria-hidden=true href=#testes-de-integração>#</a></h3><p>Os testes de integração aumentam a escala, verificando se vários componentes conseguem trabalhar juntos. Eles são <strong>coreografados</strong> e não testam a lógica de negócio, mas sim se os diferentes módulos do sistema conseguem se comunicar corretamente. Um exemplo prático seria testar se um <em>controller</em> consegue chamar corretamente um <em>repository</em>, interagir com os <em>models</em> e ainda enviar um e-mail via uma fila de mensagens.</p><h3 id=testes-de-sistema>Testes de Sistema<a hidden class=anchor aria-hidden=true href=#testes-de-sistema>#</a></h3><p>Segundo o livro, esses são os testes <strong>end-to-end (E2E)</strong>, que validam o funcionamento do sistema como um todo. Eles são mais demorados e custosos, pois envolvem interações reais entre os diversos serviços, bancos de dados e APIs externas.</p><h3 id=testes-exploratórios-manuais>Testes Exploratórios Manuais<a hidden class=anchor aria-hidden=true href=#testes-exploratórios-manuais>#</a></h3><p>Aqui entra a parte &ldquo;humana&rdquo; da pirâmide. Testadores (ou desenvolvedores destemidos) exploram o sistema buscando falhas, testando <em>edge cases</em> e tentando encontrar exceções que possam ter passado despercebidas pelos testes automatizados. Afinal, sempre existe aquele cenário bizarro que só um usuário real conseguiria descobrir.</p><hr><h2 id=gerenciamento-de-tempo>Gerenciamento de Tempo<a hidden class=anchor aria-hidden=true href=#gerenciamento-de-tempo>#</a></h2><h3 id=discussões--discordâncias>Discussões & Discordâncias<a hidden class=anchor aria-hidden=true href=#discussões--discordâncias>#</a></h3><blockquote><p>&ldquo;Qualquer discussão que não puder ser resolvida em cinco minutos não pode ser resolvida pela discussão.&rdquo;</p></blockquote><p>Se uma discussão se arrasta por mais de cinco minutos, é um sinal claro de que não existem evidências concretas sustentando nenhum dos lados. Nesse caso, o debate deixou de ser técnico e virou algo quase &ldquo;religioso&rdquo;, baseado apenas em opiniões e crenças.</p><p>Sem dados, discussões longas raramente levam a um consenso. O que fazer, então? Simples: pare de argumentar e vá atrás de mais informações. Teste, simule, faça experimentos! Em alguns casos, quando os dois lados parecem igualmente viáveis, talvez seja mais produtivo jogar uma moeda do que continuar debatendo eternamente.</p><p>Mas atenção! Se você aceitou uma decisão, entre no barco de verdade. Nada de &ldquo;concordar&rdquo; só para encerrar a conversa e depois ficar no modo passivo-agressivo, esperando algo dar errado para soltar um &ldquo;eu já sabia que isso não ia dar certo&rdquo;. Se você concordou, os acertos são seus, e os erros também.</p><h3 id=atoleiros-lamaçais-e-pântanos>Atoleiros, Lamaçais e Pântanos<a hidden class=anchor aria-hidden=true href=#atoleiros-lamaçais-e-pântanos>#</a></h3><p>Sabe o que é pior do que um beco sem saída? Um lamaçal. Pelo menos no beco sem saída você logo percebe que precisa dar meia-volta. No lamaçal, você vê a luz no fim do túnel e acredita que seguir em frente será mais rápido do que voltar—mas, surpresa! Não é.</p><p>Esse tipo de armadilha começa quando você percebe que tomou uma decisão errada (seja de design, estrutura, arquitetura&mldr;) e, ao invés de refazer o caminho, escolhe seguir em frente na esperança de que &ldquo;vai dar tudo certo&rdquo;. Spoiler: não vai.</p><p>O pensamento que prende as pessoas no lamaçal é o clássico &ldquo;Já investi muito tempo nisso, então é melhor continuar do que refazer do zero.&rdquo; Mas essa é uma ilusão perigosa. O momento certo para parar e mudar de rumo é exatamente quando você percebe que tomou a decisão errada. Insistir no erro só te afunda mais.</p><p>Pior ainda, continuar seguindo em frente não é só mentir para si mesmo—é enganar sua equipe, sua empresa e seus clientes. Você pode até dizer &ldquo;Vai ficar tudo bem!&rdquo;, mas, no fundo, sabe que está acelerando em direção ao desastre.</p><p>O segredo para evitar lamaçais? Saber a hora de dizer: <strong>&ldquo;Chega, vamos voltar e fazer direito.&rdquo;</strong></p><hr><h2 id=estimativa>Estimativa<a hidden class=anchor aria-hidden=true href=#estimativa>#</a></h2><p>Empresas tratam estimativas como comprometimentos. Desenvolvedores as tratam como palpites.</p><p>Uma estimativa é uma <em>distribuição</em>, não um número mágico. Para melhorar suas previsões, o método PERT sugere calcular três estimativas:</p><ul><li><strong>Otimista (O)</strong>: Se tudo der certo.</li><li><strong>Nominal (N)</strong>: A estimativa mais provável.</li><li><strong>Pessimista (P)</strong>: Se tudo der errado.</li></ul><p>Fórmula da previsão:</p><ul><li>$\frac{O + 4N + P}{6}$</li></ul><p>O resultado vai ser a duração da tarefa. Tendo as seguintes estimativas: O: 1, N: 3, P: 12. Teríamos (1 + 12 + 12) / 6 ou em trono de 4,2 dias.</p><p>Para sabermos a divergência padrão, podemos usar o seguinte cálculo:</p><ul><li>$\frac{P - O}{6}$</li></ul><p>Quando o resultado da divergência é grande, a incerteza também é. No exemplo de antes, a divergência é de (12 -1)/6 ou por volta de 1,8 dias</p><hr><h2 id=pressão>Pressão<a hidden class=anchor aria-hidden=true href=#pressão>#</a></h2><p>Não sucumba à tentação de &ldquo;codar sujo&rdquo; para ser rápido. Rápido e sujo são paradoxos.</p><blockquote><p>&ldquo;Você descobre no que realmente acredita quando a pressão bate. Se você abandona TDD ou código limpo na crise, nunca acreditou neles de verdade.&rdquo;</p></blockquote><p>Se você acredita que boas práticas funcionam, siga-as especialmente quando as coisas apertam.</p><hr><p>E assim encerramos. Espero que esse resumo seja útil para você (e para o eu do futuro que vai reler isso).</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.felpo.dev/>Felpo Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>